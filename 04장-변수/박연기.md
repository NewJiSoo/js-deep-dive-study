# 4.1 변수란 무잇인가? 왜 필요한가?

**변수**는 프로그래밍 언어에서 **데이터를 관리하기 위한 핵심 개념**이다!

아래와 같은 자바스크립트 코드를 실행하면 컴퓨터에서 어떤 일이 일어날지 생각해 보자.

`10 + 20`

컴퓨터는 **CPU를 통해 연산**하고, **메모리를 사용해 데이터를 기억**한다.

- **메모리**는 데이터를 저장할 수 있는 **메모리 셀의 집합체**이다.
  <div><img src="https://github.com/user-attachments/assets/cfe40aab-d4fb-4a7c-a2b8-c272d1961195" width=350></div>
- 메모리 **셀 하나의 크기**는 1**바이트 (8비트)이며**, **1바이트 단위**로 데이터를 **저장**하거나 **읽어드린다**.
- 각 셀은 **고유의 메모리 주소를 갖는다.**
- **컴퓨터는** 데이터의 종류와 상과없이 **모두 2진수로 저장**한다.
- 위 예제에서 **10과 20이** 메모리의 **임의의 위치에 저장**되고 **CPU**는 이 값을 읽어 `10 + 20` **연산을 실행**한다. 위 사진에서 **실제로는 2진수로 10과 20이 저장**되어 있지만 **편의상 10진수로 표시**하였다.
- 성공적으로 연산이 끝나면 연산 결과인 30도 임의의 위치에 저장되었지만 문제가 발생한다. 연산 결과인 30을 재사용할 수 없다는 것이다.
- 연산 결과를 재사용하고 싶은 경우 메모리 주소를 통해 저장된 값에 직접 접근하는 것 외에는 방법이 없다. 하지만 메모리 주소를 통해 값을 접근하는 것은 매우 위험한 일이다.
- 따라서 이런 문제점을 해결하기 위해 **변수**라는 메커니즘을 **제공**한다.

>[!note]
>**변수**는 하나의 값을 저장하기 위해 확보한 **메모리 공간 자체** 또는 그 **메모리 공간을 식별**하기 위해 **붙인 이름**을 말한다.

변수를 가지고 앞서 살펴본 코드를 다시 작성해보자

`let result = 10 + 20;`

연산 결과인 30은 메모리 공간에 저장된다. 이때 30을 재사용할 수 있도록 **30이 저장된 메모리 공간**에 **상징적인 이름**을 붙인 것이 바로 **변수**다.

<img src="https://github.com/user-attachments/assets/cfe40aab-d4fb-4a7c-a2b8-c272d1961195" width=350>

- **변수 이름(변수명)** : 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름 ( 위 예제에서 result )
- **변수 값** : 변수에 저장된 값 ( 위 예제에서 30 )
- **할당 (대입,저장)** : 변수에 값을 저장하는 것

**변수**는 사람이 이해할 수 있는 언어로 **값이 저장된 메모리 공간에 붙인 상징적인 이름**이다. **자바스크립트 엔진**은 변수 이름과 일치하는 메모리 주소를 통해 **메모리 공간에 접근해서 저장된 값을 반환**한다.

**변수 이름**을 통해 **저장된 값의 의미를 명확**히 할 수 있다. 좋은 **변수 이름은** **가독성을 높이**는 부수적인 효과가 있다.

개발자의 의도를 나타내는 **명확한 네이밍은 코드를 이해하기 쉽게 만들고, 협업과 품질 향상에 도움을 준다.**
# 4.2 식별자

- 식별자는 **어떤 값을 구별해서 식별할 수 있는 고유한 이름**을 말한다. (변수 이름을 식별자라 한다.)
- 식별자는 어떤 값이 저장되어 있는 **메모리 주소를 기억(저장)해야 한다.**
- 그림 4-3에서 식별자 **result는 값 30이 들어있는** **메모리 주소를 기억**해야 한다.
- 식별자는 값이 저장되어 있는 **메모리 주소와 매핑 관계**를 맺으며, 이 매핑 정보도 메모리에 저장되어야 한다.
- **`식별자는 값이 아니라 메모리 주소를 기억하고 있다!!`**
- 즉 식별자는 **메모리 주소에 붙인 이름이라고 할 수 있다.**

<img src="https://github.com/user-attachments/assets/10fdfccd-06fe-4667-b8f9-8eea2779e006" width=350>

- 식별자는 변수 이름에만 국한되지 않고, **변수, 함수, 클래스등의 이름 모두 식별자**다.
- **메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라 한다.**

# 4.3 변수 선언

**변수 선언**

- 값을 저장하기 위해 **메모리 공간을 확보**하고 **변수 이름과 메모리 공간의 주소를 연결**해서 **값을 저장할 수 있게 준비**하는 것
    - 메모리 공간은 해제가 되기 전까지 **누구도 확보된 메모리 공간을 사용할 수 없도록 보호**되므로 **안전하게 사용**할 수 있다.
- 변수를 사용할 때는 **var, let, const 키워드를 사용**한다.
    - let과 const는 var의 단점을 극복하기 위해 ES6이후에 도입되었다.

>[!note]
>**var 키워드의 단점**
>블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원해서 의도치 않게 전역 변수가 선언되어 심각한 부작용이 발생한다.
  

**var 키워드를 이용하여 변수 선언하는 방법**

`var score;` 

- 위 선언문은 아래 그림과 같이 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.
    
<img src="https://github.com/user-attachments/assets/d5bc2be7-ae83-4f6a-a158-9c2a24104300" width=350>
    
- 확보된 공간은 자바스크립트 엔진에 의해 `undefined`라는 값이 암무적으로 할당되어 초기화 한다.

**자바스크립트의 변수 선언 단계**

1. **선언 단계** 
    1. 자바스크립트 엔진에 **변수의 존재를 알린다.**
    2. **var score**에서 선언 단계를 통해 **변수 이름 score를 등록**
2. **초기화 단계**
    1. 메모리 공간을 확보하고 암묵적으**로 undefined를 할당해 초기화**한다.
    2. **var score**에서 초기화 단계를 통해 **undefined를 할당**
    3. 만약 초기화 단계가 없다면 이전에 **다른 애플리케이션이 사용했던 값이 남아 있을 수 있다**. 이를 **쓰레기 값**이라 한다. 따라서 초기화하지 않으면 변수 값을 참조 시 쓰레기 값이 나올 수 있다.
    
    **변수 이름은 어디에 등록되는가?*
>[!note]
>**모든 식별자**는 **실행 컨텍스트에 등록**된다. 
>**실행 컨텍스트**는 자바스크립트 엔진이 **소스코드를 평가**하고 실행하기 위해 **필요한 환경을 제공**하고 코드의 **실행 결과를 실제로 관리하는 영역**이다.  

모든 식별자는 반드시 선언이 필요한다. 만약 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다.

- ReferenceError는 식별자를 통해 값을 참조하려 했지만 등록된 식별자를 찾을 수 없을 때 발생하는 에러이다.
    
   <img src="https://github.com/user-attachments/assets/e357ea81-6726-4d64-a5b1-90a6e174954d" width=350>
    

# 4.4 변수 선언의 실행 시점과 변수 호이스팅

```tsx
console.log(score) // undefined

var score // 변수 선언
```

**변수 선언문 보다 변수를 참조하는 코드가 앞에 있다.** 자바스크립트는 인터프리터에 의해 한줄 씩 순차적으로 실행되므로 `**console.log(score);**`가 **가장 먼저 실행**된다. 따라서 아직 score 변수를 선언이 실행되지 않았으므로 **참조 에러가 발생할 것처럼 보인다**. **하지만 undefined가 출력된다.**

>[!note]
>**변수 선언**이 런타임이 아니라 **그 이전 단게에서 먼저 실행되기 때문**이다.


자바스크립트 코드는 **소스코드를 순차적으로 실행하기 전 소스코드 평가 과정을 거치**면서 소스코드 실행하기 위한 준비를한다. **소스코드 평가 과정**에서 **변수 선언을 포함한 모든 선언문 ( 변수, 함수 )을 소스코드에서 찾아내 먼저 실행**한다. 해당 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를  한줄씩 순차적으로 실행한다.

즉 **변수 선언이 소스코드의 어디에 있든 상관없이** **다른 코드보다 먼저 실행**된다. 따라서 변수 선언이 어디에 있든 상관없이 **어디서든 변수를 참조할 수 있다.**

**변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작**하는 자바스크립트의 고유의 특징을 **`변수 호이스팅`**이라한다.

# 4.5 값의 할당

값을 할당하는 두가지 방법

 <img src="https://github.com/user-attachments/assets/930edafb-8731-4395-82df-710be2f4e5ab" width=350>

**2개의 문으로 나누어 표현한 코드**와 **하나의 문으로 단축 표현**한 코드는 **정확히 동일하게 동작**한다. 즉 변수 선언과 값의 할당을 **하나의 문으로 표현해도 자바스크립트 엔진은 변수 선언과 값의 할당을 2개의 문으로 나누어 실행**한다.

**변수 선언(선언 단계, 초기화 단계)은 런타임 이전에 먼저 실행**되지만 **값의 할당은 런타임에 실행**된다.

```tsx
console.log(score); // undefined

var score; // 변수 선언
score = 80; // 값의 할당

console.log(score); // 80
```

```tsx
console.log(score); // undefined

var score = 80; // 변수 선언과 값의 할당

console.log(score); // 80
```

- 위와 같이 하나의 문으로 표현한 경우에도 자바스크립트 엔진은 변수의 선언과 값의 할당을 2개의 문으로 나누어 실행한다. 따라서 변수에 undefined가 할당되어 초기화되는 것은 변함 없다.
    
    <img src="https://github.com/user-attachments/assets/ff7ae41f-b802-402f-b18b-f0bcefadcbc0" width=350>
    
- 위 그림과 같이 이전 undefined가 저장되어 있던 메모리 공간을 80을 새롭게 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그곳에 80을 저장한다.
    
    ```tsx
    console.log(score) // undefined
    
    score = 80 // 값의 할당
    var score // 변수 선언
    
    console.log(score) // 80
    ```
    

# 4.6 값의 재할당

var 키워드로 선언한 **변수는 선언과 동시에 undefined로 초기화되기 때문에 엄밀히 말하면 변수에 처음으로 값을 할당하는 것도 재할당**이다. 

값을 재할당 할 수 있기 때문에 변수라고 하는 것이다. 값을 재할당할 수 없으면 상수(const)라고 하고 **ES6부터 도입된 cosnt 키워드로 상수를 표현**할 수 있다.

```tsx
var score = 80; // undefined -> 80
score = 90; // 80 -> 90
```

 <img src="https://github.com/user-attachments/assets/33a64e4a-0c2a-4735-b0ef-b9dc97d6fa85" width=350>

현재 score의 값은 90이다. **score의 이전값인 undefined와 80은** 어떤 변수도 값으로 가지고 있지 않다. 다시 말해어떤 **식별자와도 연결되어 있지 않다**. 이런 **불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제**된다. 단, **언제 해제될지는 예측할 수 없다.** 

**가비지 콜렉터**

- 메모리 공간을 주기적으로 검사하여 **더 이상 사용되지 않는 메모리를 해제하는 기능**을 말한다. **더 이상 사용되지 않는 메모리는 어떤 식별자도 참조하지 않는 메모리 공간**을 말한다. 이 처럼 가비지 콜렉터를 내장하고 있는 언어를 **매니지드 언어**라고 한다.

**매니지드 언어와 언매니지드 언어**

- 프로그래밍 언어는 **메모리 관리 방식에 따라** **매니지드 언어**와 **언매니지드 언어**로 나뉜다.
- **C언어**와 같이 개발자가 메모리를 할당하고 직접 해제하는 경우 **언매니지드 언어**라고 하며 개발자의 **역량에 따라 최적의 성능을 확보 가능** 하지만 **반대의 경우 치명적 오류를 생산할 가능성**이 있다.
- **JS와 같은 매니지드 언어**에는 메모리 관리 기능을 언어 차원에서 담당하고 **개발자의 메모리 제어를 허용하지 않는다.** 즉 개발자가 명시적으로 메모리를 할당하고 해제할 수 없다.
- **매니지드 언어**는 개발자 역량에 의존하는 부분이 상대적으로 작아져 **일정한 생산성을 확보할 수 있다는 장점**이 있지만 **성능면에서 어느 정도의 손실은 감수**할 수밖에 없다.

# 4.7 식별자 네이밍 규칙

식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.

단, 식별자는 문자, 언더스코어(_), 달러 기호($)로 시작해야한다. 

예약어는 식별자로 사용할 수 없다.

- 예약어: 프로그래밍 언어에서 상용되고 있거나 사용될 예정인 단어를 말함
    - ex ) const, let, case, class, const, import etc..

변수는 쉼표(,)로 구분해 하나의 문에서 여러 개를 선언할 수 있다. 하지만 가독성이 나빠지므로 권장하지는 않는다.

```tsx
var person, $elem, _name, first_name, val1; // 쉼표로 구분해 여러 변수 선언
```

ES5부터 식별자를 만들때 한글이나 일본어 식별자도 가능 하지만 알파벳 외의 문자로 식별자를 사용하는 것은 권장하지 않는다.

### 네이밍 컨벤션

하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙

1. 카멜 케이스 ( 첫 단어는 소문자 시작, 다음 단어부터 대문자로 시작 )
    
    `var fristName`
    
2. 스네이크 케이스 ( 두 단어의 연결을 언더 스코어(_)를 이용해 연결 )
    
    `var first_name`
    
3. 파스칼 케이스
    
    `var FisrtName` ( 모든 단어의 시작을 대문자로 표시 )
    
4. 헝가리언 케이스 (type + 식별자)
    
    `var strFisrtName`  
    

자바스크립트에서는 **일반적인 변수나 함수에서는 `카멜케이스`**를 사용하고

**생성자 함수, 클래스 이름에는 `파스칼 케이스`**를 사용한다.
