# 04장. 변수

***
### 4.0 용어 총정리



***

### 4.1 변수란 무엇인가? 왜 필요한가?

* 예제 04-01


    10 + 20
> 아무리 간단한 식이라도, 그걸 연산하는 과정은 간단하지 않다

|    구분    | 필수 개념            |   기억 저장소   | 비고                                                                                                                                   |
|:--------:|:-----------------|:----------:|:-------------------------------------------------------------------------------------------------------------------------------------|
| 사람(?진수)  | 기호, 식, 숫자, 결과... |  두뇌(뇌세포)   |                                                                                                                                      |
| 컴퓨터(2진수) | 기호, 식, 피연산자...   | 메모리(메모리 셀) | 1. 메모리(memory)는 메모리 셀(memory cell)의 집합체  <br/>2. 메모리 셀 하나의 크기는 1바이트(=8비트)  <br/>3. 컴퓨터는 메모리 셀(1바이트) 단위로 데이터를 저장(write)하거나 조회함(read). |
***
* 메모리 주소(memory address)
  * 각 셀은 고유의 메모리 주소를 지님
  * 메모리 주소는 메모리 공간의 위치를 나타냄
    * 0 ~ 메모리 크기만큼 정수로 표현
      * (예) 4GB memory: 0x00000000 ~ 0xFFFFFFFF(10진수로는 0 ~ 4,294,967,295) 까지의 메모리 주소(F는 16진수의 15)
  * 컴퓨터는 두뇌가 2진수형이라(?) 모든 데이터를 **2진수**로 처리  <br />그러므로 메모리에 저장되는 데이터는 종류를 막론하고 **모두 2진수행**
***
* 여기서 컴퓨터가 알아야 하는 필수 개념들을 좀 고상하게 표현한 게 우리가 평소에 보는 코딩적 단어(?)

|  단어(한글)   |   단어(영어)   | 의미                                                      | 4-1에서의 예                                                                                                                                                                                                                                                                       |
|:---------:|:----------:|:--------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    리터럴    |  literal   | 사람이 이해할 수 있는 문자/약속된 기호를 사용해  <br/>값을 생성하는 표기법(notation) | 10(정수 리터럴), 20(정수 리터럴)                                                                                                                                                                                                                                                         |
|   피연산자    |  operand   | 명령에 의해 처리되는 데이터                                         | 10, 20                                                                                                                                                                                                                                                                         |
|    연산자    |  operator  | 표현식(1+) 대상으로 어떤 연산을 수행할지  <br/>알려주고 하나의 값을 만드는 것        | +                                                                                                                                                                                                                                                                              |
|    표현식    | expression | 값으로 평가될 수 있는 statement                                  | 10 + 20                                                                                                                                                                                                                                                                        |
|  해석(파싱)   |  parsing   | 문자열 형태의 데이터를 특정 형식에 맞게 분석하고 변환하는 과정                     | 10, 20을 '숫자'로 자동적으로 인식하니  <br/>가시적인 parsing 따로 없는 것으로 추정                                                                                                                                                                                                                       |
|  평가(계산)   | evaluation | 계산하는 행위                                                 | 컴퓨터/사람이 메모리/머리를 굴려서 10+20의 값을 구하는 행위                                                                                                                                                                                                                                           |
|     값     |   value    | 표현식이 평가(계산)되어 생성된 결과물                                   | default(숫자 상태)대로라면 30  <br/>하지만 10, 20을 굳이 '문자열' 형태로 parsing한 이후라면 1020이 될 듯  <br/>  <br/>.toString(), String() 메소드가 각각 있는데 이 둘도 사소한(?) 차이가 있음  <br/>※ .toString()은 문자열 변환 가능한 값 아니면 에러가 나고  <br/>※ String()은 무조건 다 변환함  <br/>참고 링크: [기술블로그] <https://ji-musclecode.tistory.com/16> |                                                                                                                                     |


***

##### 예제 04-01을 계산할 때 컴퓨터 메모리상에서 정확히 어떤 일이 일어나는지 추적해 보자...

1. 예제의 숫자값 10, 20은 메모리상 임의의 위치(메모리 위치)에 기억(저장)됨
2. CPU는 이 값을 읽어들여 연산 수행
3. 연산 결과로 생성된 숫자값 30도 메모리 상 임의의 위치에 저장  <br />!! 이때 메모리에 저장되는 모든 값은 **2진수**로 저장된다는 것을 필히 기억 !!  <br />!! 그리고 CPU가 연산해서 만들어낸 숫자값 30은 **재사용이 불가**하다 !!  <br />!! 게다가 메모리 주소를 통해 값에 접근하려는 시도조차 올바른 방법이 아니다 !!
   * 메모리 주소는 **코드가 실행될 때** 메모리 상황에 따라 임의로 결정된다.  <br /> = 동일한 컴퓨터에서 동일한 코드를 실행해도 메모리 주소가 **코드가 실행될 때마다 계속 변경**된다는 뜻
   * 이래서 메모리 주소를 통해 값에 직접 접근하는 것 자체가 시스템을 멈추게 하는 치명적인 오류를 발생시키는 일이 되고
   * 이래서 자바스크립트가 개발자가 직접적인 메모리 제어를 못하게끔 막고(하고 싶어도 못 한다?)  <br />
*▶ 이때 "변수(variable)"라는 개념이 등장하게 되는데...?*  <br /> !! 메모리 공간을 식별하기 위해 붙인 이름(혹은 메모리 공간 그 자체) !!  <br/> 프로그래밍 언어의 compiler/interpreter에 의해 변수(식별용 정보)에서 메모리 공간의 주소로 정보가 치환되어 실행됨 

***

> ##### **변수**
> 1. 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름  <br />* 여기서 '하나의 값'이란 '하나의 객체'를 뜻함.  <br />** 자료구조 객체/배열의 경우 실질적으로 **여러 개의 데이터**를 **한 객체/배열**에 넣을 수 있음.  
> 2. 프로그래밍 언어에서 값을 저장&참조하는 메커니즘
> 3. 값의 위치를 가리키는 상징적인 이름
>>개발자는 변수를 통해 안전하게 값에 접근할 수 있다.  <br/>(사람이 이해하기 쉬운 언어 - 그래서 변수 이름은 심사숙고해서 정해야 함. 동료 개발자들을 위해서)

***
* 예제 04-01 > 변수를 쓴 예제 04-03으로 변경!


    var result = 10 + 20;

1. **0x00000000 ~ 0xFFFFFFFF** (실제로는 2진수) 사이에 각 메모리(**10, 20, 30**)에 배당된 임의의 메모리 주소가 3개가 있고
2. **result**는 10 + 20의 결과값인 30의 메모리 주소를 나타내는 **변수명(변수 이름, 식별자)**
3. **30**은 변수에 저장된 값이므로 **변수 값**

|       단어(한글)        |     단어(영어)     | 4-3에서의 예                                                                     | 비고                  |
|:-------------------:|:--------------:|:-----------------------------------------------------------------------------|:--------------------|
|     메모리 주소(범위)      | memory address | 0x00000000 ~ 0xFFFFFFFF 사이 임의의 값  <br/>(실제로는 2진수로 처리)                        |                     |
|         메모리         |     memory     | 10, 20, 3                                                                    |                     |
|        변수 값         |                | 30 (변수가 result밖에 없음)                                                         |                     |
| 변수 이름(변수명, 식별자의 일종) |                | result                                                                       |                     |
|     할당(대입, 저장)      |   assignment   | result에 30을 '할당'함                                                            | 변수에 값을 저장하는 행위      |
|         참조          |   reference    | result에 담긴 값은 30  <br />(var result = 10 + 20;을 콘솔창에 입력한 뒤  <br />result를 치면 30이 출력) | 변수에 저장된 값을 읽어들이는 행위 |




***

### 4.2 식별자

> **식별자(identifier)** = **메모리 상 존재하는 특정 값을 식별할 수 있는 이름**
> 1. 어떤 값을 구별해서 식별할 수 있는 **고유**한 이름  <br/>☞ '고유'해야 하니까 설정 범위 내에서 중복된 식별자(변수명)를(을) 사용할 수 없다.
> 2. 값이 저장되어있는 **메모리 주소**와 매핑 관계: **식별자는 값이 아니라 메모리 주소를 기억한다.**  <br/>☞ 이 매핑 정보도 메모리에 저장되어야 함  <br/>☞ 식별자 = **메모리 주소에 붙인 이름**이라고도 할 수 있다.
> 3. 변수 이름에만 국한되지 않음: 변수, 함수, 클래스 등 이름은 모두 식별자  <br/>(1) 변수 이름이라면? 메모리 상 존재하는 변수 값 식별 가능  <br/>(2) 함수 이름이라면? 메모리 상 존재하는 함수 식별 가능  <br/>※ **자바스크립트에서 함수는 값으로 취급된다.**  <br/>☞ 이름 계열 식별자(변수명, 함수명, 클래스명 등)은 **네이밍 규칙**을 준수해야 한다  <br/>☞ 이름 계열 식별자는 또한 **선언declaration**으로 자바스크립트 엔진에 식별자의 존재를 알린다.

***

### 4.3 변수 선언

> 변수 선언(variable declaration) = 변수를 생성하는 행위
> 1. 값을 저장하기 위한 메모리 공간을 확보(allocate)하고
> 2. 확보된 메모리 공간의 주소를 연결(name binding)함으로써 값을 저장할 수 있게 준비해줌
>>  변수 선언에 의해 확보된 메모리 공간은 확보가 해제(release)되기 전까지는 누구도 가로채지 못하게끔 보호됨, 안전하게 사용 가능
> 3. 변수를 사용하려면 반드시 선언이 필요함
>>  * 변수뿐만 아니라 모든 식별자(함수, 클래스 등)에게는 선언이 필요하다.
>>    * 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다.   <br/>☞ 식별자를 통해 값 참조를 시도했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생
>>  * 변수를 선언할 때는 var, let, const 키워드를 사용
>>    * ES6에서 let, const 키워드 도입
>>    * ES6 이전에선 var 키워드가 javascript에서 변수를 선언하는 유일한 키워드였음
>>      * ※ var 키워드의 대표적인 단점: block-level scope 대신 function-level scope 지원  <br/>☞ 의도치 않게 전역 변수가 선언되어 심각한 부작용을 야기하기도 함

***

* var 키워드: var + {변수명} 형태로 새로운 변수의 선언을 지시한다.


    var score;

<br/>


> 키워드(keyword): 자바스크립트 엔진(자바스크립트 코드를 해석, 실행)이 수행할 동작을 규정한 일종의 명령어.
> ***
> ☞ 자바스크립트 엔진은 키워드를 만나면 수행하기로 약속된 동작을 수행한다. 
 
* 변수를 선언하면?
  1. [선언 단계] 임의의 메모리 주소에 변수 이름을 등록한다. 자바스크립트 엔진에 변수의 존재를 알리게 된다.
     * 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트(execution context)에 등록된다.
  2. [초기화 단계] 값을 저장할 메모리 공간을 확보한다. 
     * 확보된 메모리 공간에는 자바스크립트 엔진에 의해 undefined 값이 암묵적으로 할당되어 초기화(initialization)된다.
       * 이는 자바스크립트의 독특한 특징이다. 
       * (위 var score; 코드의 경우 변수명 score에 undefined 값이 저장됨)

<br/>


> undefined
> ***
> ☞ 자바스크립트에서 제공하는 원시 타입 값(primitive value)이다.

<br/>


> 실행 컨텍스트(execution context)
> ***
> 1. 자바스크립트 엔진이 소스코드를 평가, 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.
> 2. 자바스크립트 엔진은 실행 컨텍스트로 식별자와 스코프를 관리한다.
> 3. 변수 이름과 변수 값은 key/value 형태로 실행 컨텍스트 내에 등록되어 관리된다.

<br/>


> 초기화(initialization)
> ***
> ☞ 변수가 선언된 이후 최초로 값을 할당하는 행위
> * 초기화 단계를 거치지 않으면 확보된 메모리 공간에 이전에 다른 application이 사용했던 값이 잔존할 수 있다.
>   * 이런 식으로 남아있는 값을 쓰레기 값(garbage value)이라고 한다.
>   * (예) 메모리 공간 확보 → 값 할당x 상태 → 곧바로 변수값 참조 → 쓰레기값 출력(즉 이전에 사용했던 값)
>     * var 키워드는 암묵적으로 초기화 수행 → 이런 식으로 쓰레기 값이 출력되진 않는다.  

<br/>


***
<br/>

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

* 예제 04-05


    console.log(score); // undefined :: 선언문 실행 시점이 런타임 시점보다 앞섬 → ReferenceError 대신 undefined 출력
    var score; // 변수 선언문


> 자바스크립트의 특징: 변수 호이스팅(variable hoisting)
> > 변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작해서 "hoisting"(끌어올리다)
> 0. 소스코드의 평가 과정 → 선언문 실행
> 1. 런타임(runtime) → 소스코드 한 줄씩(위에서 아래로) 순차적으로 실행


<br/>

***
<br/>

### 4.5 값의 할당(assignment, 대입, 저장)

* 예제 04-06


    var score; // 변수 선언
    score = 80; // score 변수에 값 할당 ※ 값 할당은 런타임(runtime)에 실행됨
***
    var score = 80; // 이런 식으로 한꺼번에 해치울 수도 있다 → This is statement

***
    console.log(score); // undefined → 선언문 실행시점이 런타임 시점보다 앞서기에 변수가 아래쪽에서 선언됐어도 undefined
    var score; // (1) 변수 선언
    score = 80; // (2) 값 할당 → 런타임때 실행 
    /* ※ 주의 ※ 이런 식으로 변수 선언과 값 할당을 따로 할 때는, 
     undefined 저장된 메모리 공간 지우고 해당 공간에 할당 값 80을 새롭게 저장하는 게 아니라,
    새로운 메모리 공간을 확봐한 후 할당값(80)을 저장한다. */ 
    console.log(score); // 바로 윗줄에서 할당받은 값인 80이 출력됨
***
    console.log(score); // 여전히 undefined
    var score = 80; // 이런 식으로 변수 선언과 값 할당을 동시에 해도 변수 선언은 런타임 이전, 값 할당은 런타임 때 각각 실행된다.
    console.log(score); // 여전히 80
***
* Quiz : 예제 04-10의 실행 결과는?? (맨 마지막 줄 console.log)
    

    console.log(score); // undefined
    score = 80; // 값 할당
    var score; // 변수 선언
    console.log(score); // → 여기서 무슨 값이 나올지 "Ask the Computer"

![예제 4-10.png](haein_images%2F%EC%98%88%EC%A0%9C%204-10.png)

***

### 4.6 값의 재할당

> 재할당: 이미 값이 할당된 변수에 새로운 값을 다시 할당하는 행위
> * 일반적인 변수는 가능
>   * (예) var(변수: variable)
> * const(상수: constant)는 불가능 → 이분은 "단 한 번"만 할당 가능한 변수의 일종
>   * 주의: const는 '반드시' 상수만을 나타내는 것은 아니다.

* 예제 04-11


    var score = 80; // (1) 변수 선언(undefined) (2) 값 할당 (새로운 메모리에 80)
    score = 90; // (3) 값 재할당 (새로운 메모리에 90) 
    // → 이 상태에서 score 이전값 undefined, 80은 어떤 식별자와도 연결되어있지 않다(garbage collector행) 
    // → 자동으로 메모리에서 해제되지만, 언제 해제될지는 예측이 불가능하다


> 가비지 콜렉터(garbage collector)
> ***
> * 애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제(release)하는 기능
>   * 더 이상 사용되지 않는 메모리 = 어떤 식별자도 참조하지 않는 메모리(공간)
> * 메모리 누수(memory leak) 방지가 목적
>   * 자바스크립트는 garbage collector를 내장하고 있는 매니지드 언어?


> 프로그래밍 언어는 메모리 방식에 따라 언매니지드/매니지드 언어로 구분할 수 있다.
> ☞ 간단하게 필요없는 메모리 자동삭제 기능이 안 달려있는/달려있는 언어라고 생각하면 될 듯
> ***
> * 언매니지드 언어: 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 메모리 제어 기능을 제공하는 언어
>   * 개발자 역량에 따라 성능이 천차만별
>     * (최적의 성능 확보 vs 치명적 오류 생산)
> * 매니지드 언어: 메모리 할당/해제용 메모리 관리 기능을 언어가 담당하고 개발자에게 메모리 제어를 허용하지 않는 언어
>   * 개발자 역량 의존성이 덜함: 언매니지드에 비해 일정한 생산성을 확보하기 쉬워지지만, (최대) 성능 손실은 감안해야 한다

***

### 4.7 식별자 네이밍 규칙

> 식별자(identifier)
> ***
> 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름
> 식별자는 네이밍 규칙을 준수해야 한다
> 1. 문자(특수문자 제외), 숫자, 일부 특수문자 포함 가능
>    * 일부 특수문자: 언더스코어(_), 달러 기호($)
> 2. 숫자로 시작하는 것은 허용X. 선두는 일부 특수문자(_, $) 혹은 문자(특수문자X)만.
> 3. 예약어(reserved word)는 식별자로 사용 불가(이미 다른 기능에서 찜해놨음)
***

> 예약어(reserved word)
> ***
> 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어(한마디로 '예약'된 상태)
> 언어마다 예약어가 조금씩 다르다

***
> \* 가 붙은 예약어는 식별자로 사용 가능하나 strict mode에서는 사용 불가능한 종류

|     예약어     |      기능       | 비고                                        ||    예약어     |           기능           | 비고 |
|:-----------:|:-------------:|:------------------------------------------|:---:|:----------:|:----------------------:|:---|
|    await    |               |                                           ||   break    |         반복문 중단         |    |
|    case     | case-when 조건문 |                                           ||   catch    | try-catch Exception 잡기 |    |
|    class    |               |                                           ||   const    |         상수 선언          |    |
|  continue   |    조건문 '통과'    |                                           ||  debugger  |                        |    |
|   default   |               |                                           ||   delete   |                        |    |
|     do      |      반복문      |                                           ||    else    |   if-else       반복문    |    |
|    enum     |               |                                           ||   export   |                        |    |
|   extends   |               |                                           ||   false    |                        |    |
|   finally   |               |                                           ||    for     |          반복문           |    |
|  function   |     함수 선언     |                                           ||     if     |   if-else       반복문    |    |
| implements* |               |  ||   import   |                        |    |
|     in      |               |                                           || instanceof |                        |    |
| interface*  |               |                                           ||    let*    |                        |    |
|     new     |               |                                           ||    null    |                        |    |
|  package*   ||||  private*  |||
| protected*  ||||  public*   |||
|   return    ||||   super    |||
|   static*   ||||   switch   |||
|    this     ||||   throw    |||
|    true     ||||    try     |||
|   typeof    ||||    var     |||
|    void     ||||   while    |||
|    with     ||||   yield    |||

***
* 예제 04-14 :: 명명 규칙에 위배된 식별자 사례


    var first-name; // _가 허용된 거지 -가 허용된 게 아니다
    var 1st; // 숫자로 시작한 건 허용X
    var this; // 예약어네?
<br/>

***
<br/>

> 변수는 쉼표(,)로 하나의 statement(문文)에서 여럿을 한번에 선언 가능 

* 예제 04-12


    var person, $elem, _name, first_name, val1;
<br/>

> ES5부터 식별자에 유니코드 문자도 허용 → 알파벳 外 한글/일본어 식별자도 사용 가능

* 예제 04-13


    var 이름, なまえ;
<br/>

> Javascript는 대소문자를 구별한다(그러므로, 예제 04-15의 변수는 각각 별개의 변수다)

* 예제 04-15


    var firstname;
    var firstName;
    var FIRSTNAME;
<br/>

> 클린 코딩을 위한 토막상식: 같이 일하는 개발자들을 위해 변수는 존재 목적을 쉽게 알 수 있게끔 작성하자!
> * 사람이 보기가 편한 변수명이 좋은 변수명~
> * 네이밍 컨벤션(naming convention)을 따르는 것도 하나의 방법

* 예제 04-16 & 04-17


    var x = 3;              // 기초 수학문제를 푸는 게 아니라면 이런 식의 변수는 존재 의의를 알 수가 없다...
    var d;                  // 변수명을 지나치게 간단하게 작성해버려서 의미를 알려면 주석을 필수적으로 달아야만 한다 → 좋은 변수명은 아니다
***
    var elapsedTimeInDays;  // 이런 식으로 개념적으로 쓰면 알아먹기 편하다
    var score = 100;        // score는 '점수'를 뜻하는 영단어니까 위의 x보다는 알아먹기 쉽다

***

> 네이밍 컨벤션(naming convention): 가독성 높이려면 따르는 게 좋은 개발자들간의 암묵적인 약속?
> ***
> 1개 이상의 영단어로 구성된 식별자를 만들 때, 가독성 좋게 단어를 구분하기 위해 규정한 명명 규칙
> * 자주 사용되는 네이밍 컨벤션이 있다
>   1. 카멜 케이스(camelCase): 일반적으로 변수명에 많이 사용(**ECMAScript사양**)
>   2. 스네이크 케이스(snake_case): 
>   3. 파스칼 케이스(PascalCase): 일반적으로 생성자 함수, 클래스 이름에 많이 사용(**ECMAScript사양**)
>   4. 헝가리언 케이스(typeHungarianCase)
>       * var strFirstName;처럼 type이랑 identifier를 붙여쓰거나
>       * var $elem = document.getElementById('myId'); 얘는 DOM 노드
>       * var observable$ = fromEvent(document, 'click');는 RxJS Observable(옵저버블) 
    