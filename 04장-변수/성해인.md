# 04장. 변수
***
### 4.0 용어 총정리



***

### 4.1 변수란 무엇인가? 왜 필요한가?

* 예제 04-01


    10 + 20
> 아무리 간단한 식이라도, 그걸 연산하는 과정은 간단하지 않다

|    구분    | 필수 개념            |   기억 저장소   | 비고                                                                                                                                   |
|:--------:|:-----------------|:----------:|:-------------------------------------------------------------------------------------------------------------------------------------|
| 사람(?진수)  | 기호, 식, 숫자, 결과... |  두뇌(뇌세포)   |                                                                                                                                      |
| 컴퓨터(2진수) | 기호, 식, 피연산자...   | 메모리(메모리 셀) | 1. 메모리(memory)는 메모리 셀(memory cell)의 집합체  <br/>2. 메모리 셀 하나의 크기는 1바이트(=8비트)  <br/>3. 컴퓨터는 메모리 셀(1바이트) 단위로 데이터를 저장(write)하거나 조회함(read). |
***
* 메모리 주소(memory address)
  * 각 셀은 고유의 메모리 주소를 지님
  * 메모리 주소는 메모리 공간의 위치를 나타냄
    * 0 ~ 메모리 크기만큼 정수로 표현
      * (예) 4GB memory: 0x00000000 ~ 0xFFFFFFFF(10진수로는 0 ~ 4,294,967,295) 까지의 메모리 주소(F는 16진수의 15)
  * 컴퓨터는 두뇌가 2진수형이라(?) 모든 데이터를 **2진수**로 처리  <br />그러므로 메모리에 저장되는 데이터는 종류를 막론하고 **모두 2진수행**
***
* 여기서 컴퓨터가 알아야 하는 필수 개념들을 좀 고상하게 표현한 게 우리가 평소에 보는 코딩적 단어(?)

|  단어(한글)   |   단어(영어)   | 의미                                                      | 4-1에서의 예                                                                                                                                                                                                                                                                       |
|:---------:|:----------:|:--------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    리터럴    |  literal   | 사람이 이해할 수 있는 문자/약속된 기호를 사용해  <br/>값을 생성하는 표기법(notation) | 10(정수 리터럴), 20(정수 리터럴)                                                                                                                                                                                                                                                         |
|   피연산자    |  operand   | 명령에 의해 처리되는 데이터                                         | 10, 20                                                                                                                                                                                                                                                                         |
|    연산자    |  operator  | 표현식(1+) 대상으로 어떤 연산을 수행할지  <br/>알려주고 하나의 값을 만드는 것        | +                                                                                                                                                                                                                                                                              |
|    표현식    | expression | 값으로 평가될 수 있는 statement                                  | 10 + 20                                                                                                                                                                                                                                                                        |
|  해석(파싱)   |  parsing   | 문자열 형태의 데이터를 특정 형식에 맞게 분석하고 변환하는 과정                     | 10, 20을 '숫자'로 자동적으로 인식하니  <br/>가시적인 parsing 따로 없는 것으로 추정                                                                                                                                                                                                                       |
|  평가(계산)   | evaluation | 계산하는 행위                                                 | 컴퓨터/사람이 메모리/머리를 굴려서 10+20의 값을 구하는 행위                                                                                                                                                                                                                                           |
|     값     |   value    | 표현식이 평가(계산)되어 생성된 결과물                                   | default(숫자 상태)대로라면 30  <br/>하지만 10, 20을 굳이 '문자열' 형태로 parsing한 이후라면 1020이 될 듯  <br/>  <br/>.toString(), String() 메소드가 각각 있는데 이 둘도 사소한(?) 차이가 있음  <br/>※ .toString()은 문자열 변환 가능한 값 아니면 에러가 나고  <br/>※ String()은 무조건 다 변환함  <br/>참고 링크: [기술블로그] <https://ji-musclecode.tistory.com/16> |                                                                                                                                     |


***

##### 예제 04-01을 계산할 때 컴퓨터 메모리상에서 정확히 어떤 일이 일어나는지 추적해 보자...

1. 예제의 숫자값 10, 20은 메모리상 임의의 위치(메모리 위치)에 기억(저장)됨
2. CPU는 이 값을 읽어들여 연산 수행
3. 연산 결과로 생성된 숫자값 30도 메모리 상 임의의 위치에 저장  <br />!! 이때 메모리에 저장되는 모든 값은 **2진수**로 저장된다는 것을 필히 기억 !!  <br />!! 그리고 CPU가 연산해서 만들어낸 숫자값 30은 **재사용이 불가**하다 !!  <br />!! 게다가 메모리 주소를 통해 값에 접근하려는 시도조차 올바른 방법이 아니다 !!
   * 메모리 주소는 **코드가 실행될 때** 메모리 상황에 따라 임의로 결정된다.  <br /> = 동일한 컴퓨터에서 동일한 코드를 실행해도 메모리 주소가 **코드가 실행될 때마다 계속 변경**된다는 뜻
   * 이래서 메모리 주소를 통해 값에 직접 접근하는 것 자체가 시스템을 멈추게 하는 치명적인 오류를 발생시키는 일이 되고
   * 이래서 자바스크립트가 개발자가 직접적인 메모리 제어를 못하게끔 막고(하고 싶어도 못 한다?)  <br />
*▶ 이때 "변수(variable)"라는 개념이 등장하게 되는데...?*  <br /> !! 메모리 공간을 식별하기 위해 붙인 이름(혹은 메모리 공간 그 자체) !!  <br/> 프로그래밍 언어의 compiler/interpreter에 의해 변수(식별용 정보)에서 메모리 공간의 주소로 정보가 치환되어 실행됨 

***

> ##### **변수**
> 1. 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름  <br />* 여기서 '하나의 값'이란 '하나의 객체'를 뜻함.  <br />** 자료구조 객체/배열의 경우 실질적으로 **여러 개의 데이터**를 **한 객체/배열**에 넣을 수 있음.  
> 2. 프로그래밍 언어에서 값을 저장&참조하는 메커니즘
> 3. 값의 위치를 가리키는 상징적인 이름
>>개발자는 변수를 통해 안전하게 값에 접근할 수 있다.  <br/>(사람이 이해하기 쉬운 언어 - 그래서 변수 이름은 심사숙고해서 정해야 함. 동료 개발자들을 위해서)

***
* 예제 04-01 > 변수를 쓴 예제 04-03으로 변경!


    var result = 10 + 20;

1. **0x00000000 ~ 0xFFFFFFFF** (실제로는 2진수) 사이에 각 메모리(**10, 20, 30**)에 배당된 임의의 메모리 주소가 3개가 있고
2. **result**는 10 + 20의 결과값인 30의 메모리 주소를 나타내는 **변수명(변수 이름, 식별자)**
3. **30**은 변수에 저장된 값이므로 **변수 값**

|       단어(한글)        |     단어(영어)     | 4-3에서의 예                                                                     | 비고                  |
|:-------------------:|:--------------:|:-----------------------------------------------------------------------------|:--------------------|
|     메모리 주소(범위)      | memory address | 0x00000000 ~ 0xFFFFFFFF 사이 임의의 값  <br/>(실제로는 2진수로 처리)                        |                     |
|         메모리         |     memory     | 10, 20, 3                                                                    |                     |
|        변수 값         |                | 30 (변수가 result밖에 없음)                                                         |                     |
| 변수 이름(변수명, 식별자의 일종) |                | result                                                                       |                     |
|     할당(대입, 저장)      |   assignment   | result에 30을 '할당'함                                                            | 변수에 값을 저장하는 행위      |
|         참조          |   reference    | result에 담긴 값은 30  <br />(var result = 10 + 20;을 콘솔창에 입력한 뒤  <br />result를 치면 30이 출력) | 변수에 저장된 값을 읽어들이는 행위 |




***

### 4.2 식별자

> **식별자(identifier)** = **메모리 상 존재하는 특정 값을 식별할 수 있는 이름**
> 1. 어떤 값을 구별해서 식별할 수 있는 **고유**한 이름  <br/>☞ '고유'해야 하니까 설정 범위 내에서 중복된 식별자(변수명)를(을) 사용할 수 없다.
> 2. 값이 저장되어있는 **메모리 주소**와 매핑 관계: **식별자는 값이 아니라 메모리 주소를 기억한다.**  <br/>☞ 이 매핑 정보도 메모리에 저장되어야 함  <br/>☞ 식별자 = **메모리 주소에 붙인 이름**이라고도 할 수 있다.
> 3. 변수 이름에만 국한되지 않음: 변수, 함수, 클래스 등 이름은 모두 식별자  <br/>(1) 변수 이름이라면? 메모리 상 존재하는 변수 값 식별 가능  <br/>(2) 함수 이름이라면? 메모리 상 존재하는 함수 식별 가능  <br/>※ **자바스크립트에서 함수는 값으로 취급된다.**  <br/>☞ 이름 계열 식별자(변수명, 함수명, 클래스명 등)은 **네이밍 규칙**을 준수해야 한다  <br/>☞ 이름 계열 식별자는 또한 **선언declaration**으로 자바스크립트 엔진에 식별자의 존재를 알린다.

***

### 4.3 변수 선언

> 변수 선언(variable declaration) = 변수를 생성하는 행위
> 1. 값을 저장하기 위한 메모리 공간을 확보(allocate)하고
> 2. 확보된 메모리 공간의 주소를 연결(name binding)함으로써 값을 저장할 수 있게 준비해줌
>>  변수 선언에 의해 확보된 메모리 공간은 확보가 해제(release)되기 전까지는 누구도 가로채지 못하게끔 보호됨, 안전하게 사용 가능
> 3. 변수를 사용하려면 반드시 선언이 필요함
>>  * 변수뿐만 아니라 모든 식별자(함수, 클래스 등)에게는 선언이 필요하다.
>>    * 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다.   <br/>☞ 식별자를 통해 값 참조를 시도했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생
>>  * 변수를 선언할 때는 var, let, const 키워드를 사용
>>    * ES6에서 let, const 키워드 도입
>>    * ES6 이전에선 var 키워드가 javascript에서 변수를 선언하는 유일한 키워드였음
>>      * ※ var 키워드의 대표적인 단점: block-level scope 대신 function-level scope 지원  <br/>☞ 의도치 않게 전역 변수가 선언되어 심각한 부작용을 야기하기도 함

***

* var 키워드: var + {변수명} 형태로 새로운 변수의 선언을 지시한다.


    var score;

> 키워드(keyword): 자바스크립트 엔진(자바스크립트 코드를 해석, 실행)이 수행할 동작을 규정한 일종의 명령어.
> ***
> ☞ 자바스크립트 엔진은 키워드를 만나면 수행하기로 약속된 동작을 수행한다. 
 
* 변수를 선언하면?
  1. [선언 단계] 임의의 메모리 주소에 변수 이름을 등록한다. 자바스크립트 엔진에 변수의 존재를 알리게 된다.
     * 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트(execution context)에 등록된다.
  2. [초기화 단계] 값을 저장할 메모리 공간을 확보한다. 
     * 확보된 메모리 공간에는 자바스크립트 엔진에 의해 undefined 값이 암묵적으로 할당되어 초기화(initialization)된다.
       * 이는 자바스크립트의 독특한 특징이다. 
       * (위 var score; 코드의 경우 변수명 score에 undefined 값이 저장됨)


> undefined
> ***
> ☞ 자바스크립트에서 제공하는 원시 타입 값(primitive value)이다.


> 실행 컨텍스트(execution context)
> ***
> 1. 자바스크립트 엔진이 소스코드를 평가, 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.
> 2. 자바스크립트 엔진은 실행 컨텍스트로 식별자와 스코프를 관리한다.
> 3. 변수 이름과 변수 값은 key/value 형태로 실행 컨텍스트 내에 등록되어 관리된다.


> 초기화(initialization)
> ***
> ☞ 변수가 선언된 이후 최초로 값을 할당하는 행위
> * 초기화 단계를 거치지 않으면 확보된 메모리 공간에 이전에 다른 application이 사용했던 값이 잔존할 수 있다.
>   * 이런 식으로 남아있는 값을 쓰레기 값(garbage value)이라고 한다.
>   * (예) 메모리 공간 확보 → 값 할당x 상태 → 곧바로 변수값 참조 → 쓰레기값 출력(즉 이전에 사용했던 값)
>     * var 키워드는 암묵적으로 초기화 수행 → 이런 식으로 쓰레기 값이 출력되진 않는다.  

***

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

***

### 4.5 값의 할당

***

### 4.6 값의 재할당

***

### 4.7 식별자 네이밍 규칙