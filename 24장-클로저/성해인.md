# 24. 클로저

> A closure is the combination of a function and ***the lexical environment within which that function was declared***
> =  클로저는 함수와 그 ***함수가 선언된 렉시컬 환경***과의 조합이다.
> ***
> - MDN
> ***
> > 여기에서 중요한 말은 ***함수가 선언된 렉시컬 환경***이라는 표현
> > 그리고 자바스크립트가 렉시컬 스코프를 따르는 프로그래밍 언어라는 사실


### 예제 24-01: 내부의 중첩 함수라면 scope에 있는 변수 참조 가능
```Javascript
const x = 1;

function outerFunc() {
    const x = 10;
    function innerFunc() { // innerFunc함수가 outerFunc 함수 내부에서 정의된 중첩 함수이기에 outerFunc 함수 변수에 접근 가능(호출만으로는 부족)
        // 여기서 innerFunc 영역이 outerFunc 내부 변수라는 게 'lexical environment'
        console.log(x); // 10
    }
    innerFunc();
}

outerFunc();
```

### 예제 24-02: 단순 호출로는 내부 변수 접근 불가
```Javascript
const x = 1;

function outerFunc() {
    const x = 10;
    innerFunc(); // 그저 내부 호출일 뿐
}

function innerFunc() { // '선언'은 outerFunc 바깥 -> outerFunc 내부 변수 참조 불가. 전역 변수 들고 옴
    console.log(x); // 1
}
outerFunc();
```

## 24.1 렉시컬 스코프
> 렉시컬 스코프(정적 스코프): 자바스크립트  엔진은 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정하는데, 이때 이 상위 스코프

### 예제 24-03
```Javascript
const x = 1;

function foo() { // foo 함수는 전역에서 정의되었으니 전역 함수 = 상위 스코프: 전역
    const x = 10;
    bar(); // 호출 위치는 별 상관 없음. 정의된 위치가 matters
}

function bar() { // bar 함수도 전역에서 정의되었으니 전역 함수 = 상위 스코프: 전역
    console.log(x);
}

foo();
bar();
```

<br>

## 24.2 함수 객체의 내부 슬롯 [[Environment]]
> 렉시컬 스코프가 가능하려면 어떻게 해야 할까?
> > 자신이 호출되는 환경과는 상관없이, 정의된 환경(상위 스코프)이 어디였는지 정보값이 있어야 한다
> > * 이 정보값을 항상 들고 다닌다 -> 내부 슬롯에 보관 -> 이 내부 슬롯이 [[Environment]]
> * 함수 정의가 평가되어 함수 객체를 생성하는 시점 = 함수가 정의된 환경 = 상위 함수가 평가/실행되고 있는 시점
>   * 이때 현재 실행 중인 실행 컨텍스트는 상위 함수의 실행 컨텍스트
>   * (예) 전역에서 정의된 함수 선언문 -> 전역 코드가 평가되는 시점에 평가, 함수 객체 생성<br>이 녀석의 Environment는 전역 코드 평가 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경인 전역 렉시컬 환경의 참조가 자연스럽게 저장됨
>   * 함수 객체는 자신이 존재하는 한 [[Environment]]에 저장한 렉시컬 환경의 참조(상위 스코프)를 기억한다.

### 예제 24-04: 렉시컬 스코프 예제 복습
```Javascript
const x = 1;
function foo() {
    const x = 10;
    bar(); // bar의 호출 환경과 bar의 상위 스코프는 관계없음 // 상위 스코프는 함수 정의 환경(위치)에 따라 결정되기 때문
}

function bar() { // 함수 bar는 전역에서 생성됐으니 상위 스코프 = 전역 렉시컬 환경 // 이 정보는 내부슬롯 [[Environment]]에 들어있음
    console.log(x);
}

foo();
bar();
```

### 그림 24-1: 함수 객체의 내부 슬롯[[Environment]]에는 상위 스코프가 저장된다.
![img.png](shi_images/img.png)

* 렉시컬 스코프의 실체?

  * foo함수, bar함수의 상위 스코프는 *전역* -> [[Environment]]에 저장된 상태(전역 렉시컬 환경 참조) & 두 함수는 전역 객체 window의 메서드
  0. 함수 호출
  1. 함수 내부로 코드 제어권 이동
  2. 함수 코드 평가 시작

  * 함수 코드 평가 단계
  1. 함수 실행 컨텍스트 생성
  2. 함수 렉시컬 환경 생성
     1. 함수 환경 레코드 생성
     2. this 바인딩
     3. 외부 렉시컬 환경에 대한 참조 결정 <- 이때 [[Environment]]에 저장된 전역 렉시컬 환경 참조가 할당됨 

<br>

## 24.3 클로저와 렉시컬 환경

> 클로저(closure): 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 중첩 함수는 이미 생명 주기가 종료된 외부 함수의 변수를 참조할 수 있다.<br>이때, 이 중첩 함수를 클로저라고 칭한다.

### 예제 24-05: 좀비 변수 x?
```Javascript
const x = 1;

function outer() {
    const x = 10;
    const inner = function() {console.log(x)};
    return inner;
}

const innerFunc = outer();
innerFunc(); // innerFunc() 실행 -> const innerFunc에서 outer함수 호출 
// -> const inner 선언하면서 console.log(x); 찍고 (이때 x = 10이라 10 출력) 
// return값으로 희한하게도 단순 변수값이 아니라 함수를 할당한 변수를 반환함
// 여기(innerFunc() <- outer() 반환값)서 outer 함수 안에서만 선언됐던 변수 x 에 할당된 값 10이 찍혀나옴
```

* x는 지역 변수지만 innerFunc()에서 변수값이 찍혀나옴. 
  * 실행 컨텍스트 스택에서 제거된 x가 부활이라도 한 것처럼 동작?
    * ***실행 컨텍스트는 지워져도 렉시컬 환경까지 소멸하는 것은 아님***
  * 함수 선언 변수 inner는 평가될 때 상위 스코프릃 [[Environment]] 내부 슬롯에 저장했고, 이는 함수가 존재하는 한 유지됨

### 그림 24-2: 전역 함수 객체의 상위 스코프 결정(예제 24-05 원리 설명)
![img_1.png](shi_images%2Fimg_1.png)

### 그림 24-3: 중첩 함수의 상위 스코프 결정(예제 24-05 원리 설명)
![img_2.png](shi_images%2Fimg_2.png)

### 그림 24-4: 실행 컨텍스트가 제거되어도 렉시컬 환경은 유지가 돼~(예제 24-05 원리 설명 - outer함수)
![img_3.png](shi_images%2Fimg_3.png)

### 그림 24-5: 그래서 외부 함수가 소멸해도, 반환된 중첩 함수는 외부 함수의 변수를 참조 가능
![img_4.png](shi_images%2Fimg_4.png)

<br>

### 예제 24-06: 이 코드를 브라우저에서 디버깅 모드로 실행하면...?
```html
<!DOCTYPE html>
<html>
<body>
  <script>
    function foo() {
      const x = 1;

      // 일반적으로 클로저라고 하지 않는다.
      // bar 함수는 클로저였지만 곧바로 소멸한다.
      function bar() {
        debugger;
        // 상위 스코프의 식별자를 참조한다.
        console.log(x);
      }
      bar();
    }

    foo();
  </script>
</body>
</html>
```

### 그림 24-6: 이렇게 됩니다
![img_5.png](shi_images%2Fimg_5.png)


## 24.4 클로저의 활용
## 24.5 캡슐화와 정보 은닉
## 24.6 자주 발생하는 실수