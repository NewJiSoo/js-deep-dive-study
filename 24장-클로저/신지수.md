# 24. 클로저
## 24.1 렉시컬 스코프
자바스크립트 엔진은 함수가 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프(정적 스코프)라 한다.


## 24.2 함수 객체의 내부 슬롯 [[Environment]]
함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다. 
함수 객체의 내부 슬롯 [[Environment]]에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프다.

## 24.3 클로저와 렉시컬 환경
외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이런 중첩 함수를 클로저하고 부른다.
```js
const x = 1;

function outer() {
    const x = 10;
    const inner = function () { console.log(x); };
    return inner;
}

// outer 함수를 호출하면 중첩함수 inner를 반환한다.
// 그리고 outer 함수의 실행 컨텍스트는 실행 컨텍스트에서 팝되어 제거된다. (생명 주기 종료)
const foo = outer();
foo(); // 10
```

코드에서 outer함수의 실행 컨텍스트는 스택에서 제거되지만 outer함수의 렉시컬 환경까지 소멸하는 것은 아니다. inner함수의 [[Environment]] 내부 슬롯에 의해 참조되고 있고, inner함수는 전역 변수 foo에 의해 참조되고 있기 때문이다.

## 24.4 클로저의 활용
클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 이는 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.


## 24.6 클로저 사용 시 자주 발생하는 실수
```js
var foo = [];
for (var i = 0; i < 3; i++) {
    foo[i] = function () { return i; };
}

for (var j = 0; j < foo.length; j++) {
    console.log(foo[j]()); // 3 3 3
}
```

코드에서 `[0, 1, 2]`가 순차적으로 반환할 것 같지만 그렇지 않다.

전역 변수 `i`에 `0, 1, 2`가 순차적으로 할당되지만 함수레벨 스코프를 갖기 때문에 `foo` 함수를 호출하면 전역변수 `i`를 참조하여 for문 종료 전 할당 되었던 `i`의 값인 `3`이 출력된다.

ES6의 let 키워드를 사용하면 이같은 번거로움이 해결된다.
```jsx
const foo = [];
for (let i = 0; i < 3; i++) {
    foo[i] = function () { return i; };
}

for (let i = 0; i < foo.length; i++) {
    console.log(foo[i]()); // 0 1 2
}
```
let 키워드로 선언한 변수를 사용하면 for 문의 코드 블록이 반복 실행될 때마다 독립적인 렉시컬 환경을 생성해 식별자 값을 유지한다.