# 07장. 연산자(operator)
***
> 표현식 = 연산자 & 피연산자
> * 표현식: 피연산자와 연산자의 조합, 값으로 평가 가능
> * 피연산자: "값"이라는 명사 역할, 연산의 대상
> * 연산자: 피연산자를 "연산한다"(그리고 새로운 값을 만든다)는 동사 역할
>   * "연산"은 operation
***

### 종류

1. <big>산술(arithmetic) 연산자</big>
   * 피연산자 대상으로 수학적 계산 수행, 새로운 숫자 값 생성
     * 수학적 계산 & 숫자값 반환이 불가능할 경우 NaN 반환(Not a Number)
   * (예) 5 * 4 // 20
   1. 이항(binary) 산술 연산자
      * **2개**의 피연산자를 산술 연산하여 숫자 결과값 생성
      * 모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수 효과(side effect)가 없음  <br/>= 어떤 산술 연산을 해도 피연산자의 값이 바뀌는 게 아니라 **새로운 값을 만드는 개념**
      * (예) +(덧셈), -(뺄셈), *(곱셈), /(나눗셈), %(나머지)
   2. 단항(unary) 산술 연산자
      * **1개**의 피연산자를 산술 연산하여 숫자 결과값 생성
        * 부수 효과 없음
          * \+ (어떠한 효과도 없음)
            * 단, 숫자 타입이 아닌 피연산자에 붙을 경우 피연산자를 숫자 타입으로 변환하는 효과가 있다.  <br/>그래도 역시 피연산자를 변경하는 것은 아니기에 부수 효과는 없다.
          * \- (양수, 음수간 반전)
            * \+ 연산자와 마찬가지로 숫자 타입 외 피연산자에 붙으면 해당 피연산자를 숫자 타입으로 변환한다.
        * 부수 효과 있음: 증가/감소 연산자(increment/decrement operator)
          * ++ (증가): 피연산자의 값을 **변경**하는 부수 효과가 있음
          * -- (감소): 피연산자의 값을 **변경**하는 부수 효과가 있음
          * ++, --는 앞에 붙었을 땐 전위(prefix) 뒤에 붙었을 땐 후위(postfix) 증가/감소 연산자라 불리며,  <br/>전위일 땐 피연산자 값 증가/감소 후 연산 수행  <br/>후위일 땐 연산 수행 후 피연산자 값 증가/감소시킨다.
   3. 문자열 연결 연산자
      * \+ 연산자는 피연산자 중 하나 이상이 문자열일 경우 문자열 연결 연산자로 동작
        * (예) 'My name is ' + 'Lee' // 'My name is Lee'
      * 암묵적 타입 변환(implicit coercion), 타입 강제 변환(type coercion):  <br>개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 반환되는 경우도 있음
        * Boolean
          * true → 1
          * false → 0
          * null → 0
        * undefined → NaN
        * +/- 단항 연산자도 암묵적 타입 변환의 일종
2. <big>할당(assignment) 연산자</big>
    * 우항의 피연산자 평가 결과를 좌항의 변수에 할당한다.
    * 부수 효과가 **있다**: 좌항의 변수에 값을 할당하므로 변수 값이 변하기 때문.
    * (예) =, +=, -=, *=, /=, %=
        *     var x;      
              x = 10;
              console.log(x); // 10
              x += 5;
              console.log(x); // 15
              x -= 5;
              console.log(x); // 10
              x *= 5;
              console.log(x); // 50
              x /= 5;
              console.log(x); // 10
              x %= 5;
              console.log(x); // 0
              
              var str = 'My name is ';
              str += 'Lee';
              console.log(str); // 'My name is Lee'
    * 할당문은 문(statement: 값으로 평가되는 표현식)으로서 할당된 값으로 평가된다.
      *     var x;
            console.log(x = 10); // 10 // 할당문은 표현식인 문이다
            
            var a, b, c;
            a = b = c = 0;
            console.log(a, b, c); // 0 0 0 // 이런 식으로 연쇄 할당도 가능하다(여러 변수, 동일한 값)
3. <big>비교(comparison) 연산자</big>
   * 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.
     * (예) 3 > 5 // false
     * 주로 제어문 조건식에서 많이 활용(if문, for문 등)
   1. 동등 비교(loose equality)/일치 비교(strict equality) 연산자
      * 기본적으로 좌변과 우변이 같은 값인지 여부를 boolean 값으로 반환한다.  <br>동등 비교, 일치 비교 연산자는 **비교 엄격성**의 정도가 다르다(비교시 암묵적 타입변환 있으면 loose, 없어서 타입까지 따지면 strict)  <br>부수 효과는 없다
        * 동등 비교는 ==, != 연산자 사용: 예측하기 어려운 결과(안티 패턴)를 만들어내니 사용 지양 추천
        * 일치 비교는 ===, !== 연산자 사용: NaN, 0만 조심하면 대체로 예측 가능한 결과를 만들어내니 사용 추천
          * NaN은 자신과 일치하지 않는 유일한 value이다.  <br>(예) NaN === NaN; // false
          * 0 === -0 // true
        * 일치 비교보다 이해하기 쉬운 건 ES6부터 도입된 **Object.js**
          * 일부 사례만 제외하고는 일치 비교 연산자와 동일하게 동작한다.  <br>아래의 사례는 그 '일부 사례'
            * Object.js(NaN, NaN); // true
            * Object.js(-0, +0); // false
   2. 대소 관계 비교 연산자
      * 피연산자의 크기를 비교하여 boolean 값 반환(부수 효과 없음)
        * \>, \<, \>=, \<=
      * 위에서 보다시피 같거나 작다, 같거나 크거나 등의 개념을 표현할 때 등호가 우측에 온다
4. <big>삼항 조건 연산자(ternary operator)</big>
   * 조건식의 평가 결과에 따라 반환할 값을 결정한다(부수 효과는 없다)
     * `조건식 ? true시 반환값 : false시 반환값`
   * Javascript의 유일한 삼항 연산자: 가독성이 좋다.
   * 값으로 평가할 수 있는 표현식인 문(statement)이다.
     * if-else문과 기능이 유사하지만, if-else문과는 달리 **값처럼 사용할 수 있다**(if-else문은 표현식이 아닌 문)
     * 다른 표현식의 일부가 될 수 있어 유용하다.
5. <big>논리(logical) 연산자</big>
   * 우항과 좌항의 피연산자를 논리 연산한다. 부수 효과는 없다.
     * 논리합OR: ||
       * 평가 결과는 boolean 값이 아닐 수도 있으며, 이 경우 2개의 피연산자 중 어느 한쪽으로 평가된다.
     * 논리곱AND: &&
        * (예) `true && false // false`
        * 평가 결과는 boolean 값이 아닐 수도 있으며, 이 경우 2개의 피연산자 중 어느 한쪽으로 평가된다.
          * (예) `'Cat' && 'Dog'; // 'Dog'`
     * 부정NOT: !
       * 논리부정 연산자는 언제나 boolean 값을 반환한다.
   * 피연산자가 반드시 boolean 값일 필요는 없지만, 만약 아니라면 boolean 타입으로 암묵적 타입 변환된다.
   * 드 모르간의 법칙
     `!(x || y) === (!x && !y)
     !(x && y) === (!x || !y)`
6. <big>쉼표 연산자</big>
   * 왼쪽 피연산자부터 차례대로 피연산자를 평가한 뒤 평가가 끝나면 '마지막' 피연산자의 평가 결과를 반환한다.
     * (예) `var x, y, z;
     x = 1, y = 2, z = 3; // 3`
7. <big>그룹 연산자</big>
   * 소괄호로 피연산자를 감싸는 것으로 연산자의 우선순위를 조절할 수 있다.
     * 그룹 연산자(즉, \(\)로 감싼 영역)는 **연산자 우선순위가 가장 높다**
8. <big>typeof 연산자</big>
   * 피연산자의 데이터 타입을 문자열로 반환한다.
      * (예) typeof 'Hi' // string
   * 데이터 타입을 뜻하는 **7가지 문자열** 중 하나를 반환한다  <br>※ "null"은 반환하지 않는다. 그러므로 null 여부를 가리려면 객체끼리 === 연산자로 type 비교를 해야 한다.
     1. string
        (조심할 예) 빈 문자열('')
     2. number
        (조심할 예) NaN
     3. boolean
     4. undefined
        * 미선언 식별자를 typeof 연산자로 연산 시도할 시 ReferenceError 대신 undefined를 반환한다
     5. symbol
     6. object
        (조심할 예) null, [], {}, /test/gi
     7. function
9. <big>지수 연산자</big>
   * 좌항 피연산자를 밑(base)으로, 우항 피연산자를 지수(exponent)로 거듭 제곱한 후 숫자 값을 반환한다.
     * (예) `2 ** 0; // 1`
     * 음수를 거듭제곱 밑으로 사용하려면 괄호로 묶어야 한다.
       * (예) `-5 ** 2; // SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence`
       * (예2) `(-5) ** 2; // 25`
   * ES7에서 도입되었다
     * 지수 연산자 도입 이전: **Math.pow()** 메서드 사용
       * (예) Math.pow(2, -2); // 0.25
   * 이항 연산자 중에서 우선순위가 제일 높다.
   * 다른 산술 연산자처럼 할당 연산자와 함께 사용 가능하다
     * (예) `5 **= 2; // 25`
10. <big>기타 연산자</big>
    1. ?. 옵셔널 체이닝 연산자
    2. ?? null 병합 연산자
    3. delete 프로퍼티 삭제
    4. new 생성자 함수 호출시 인스턴스 생성용
    5. instanceof 좌변 객체가 우변 생성자 함수와 연결된 인스턴스인지 판별
    6. in 프로퍼티 존재 확인
11. <big>연산자의 부수 효과</big>
    * 새로운 값을 생성하기보다 다른 코드에 영향을 주는 부수 효과가 있는 연산자 목록
        1. 할당 연산자
           `var x; x = 1;`
        2. 증가/감소 연산자
           `var x; x++;`
        3. delete 연산자
           `var o = {a:1}; delete o.a;`
12. <big>연산자 우선순위</big>
    * 한 statement에 연산자가 여럿일 때, 어느 연산자부터 실행될 것인지 정해놓은 순서  <br>우선순위가 높을수록 먼저 실행된다
      > 연산자 종류가 많기에 괜히 다 외우기보다는 연산자 우선순위 가장 높은 그룹 연산자()를 빈번히 사용하는 편이 정신 건강에 좋다?
    * 우선순위별 연산자 목록
      1. **그룹연산자()**
      2. new(매개변수 존재), .. \[\](프로퍼티 접근), ()(함수 호출), ?.(옵셔널 체이닝 연산자)
      3. new(매개변수 미존재)
      4. x++, x--
      5. !x, +x, -x, ++x, --x, typeof, delete
      6. **
      7. *, /, %
      8. +, -
      9. <, <=, >, >=, in, instanceof
      10. ==, !=, ===, !==
      11. ??(null 병합 연산자)
      12. &&
      13. ||
      14. ? ... : ...
      15. 할당 연산자(=, +=, -=, ...)
      16. ,
13. <big>연산자 결합 순서</big>
    * 좌항 → 우항순으로 평가를 수행할 것인지,  <br/> 우항 → 좌항순으로 평가를 수행할 것인지 나타내는 순서
      * 좌항 → 우항: +, -, /, %, <, <=, >, >=, &&, ||, ., [], (), ??, ?., in, instanceof
      * 우항 → 좌항: ++, --, 할당 연산자(=, +=, -=, ...), !x, +x, -x, ++x, --x, typeof, delete, ? ... : ..., **