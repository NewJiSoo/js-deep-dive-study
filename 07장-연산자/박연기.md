**연산자는** 하나 이상의 **표현식**으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 **하나의 값을 만든다.**

- 표현식 : 값으로 평가될 수 있는 문

이때 연산의 대상을 피연산자라 한다. **피연산자는 값으로 평가될 수 있는 표현식**이어야 한다. 피연산자와 연산자의 조합으로 이뤄진 **연산자 표현식도 값으로 평가될 수 있는 표현식**이다. 

```jsx
// 산술 연산자
5 * 4 // 20

// 문자열 연결 연산자
"My name is " + "LEE" // My name is Lee

// 할당 연산자
color = "red" // red

// 비교 연산자
3 > 5 // false

// 논리 연산자
true && false // false

// 타입 연산자
typeof "Hi" // string
```

---

# 7.1 산술 연산자

산술 연산자는 피연산자를 대상으로 계산을 수행해 **새로운 숫자 값을 만든다.** 산술 연산이 불가능한 경우 NaN을 반환한다.

산술 연산자는 피연산자의 개수에 따라 **이항 산술 연산자**와 **단항 산술 연산자**로 구분할 수 있다.

### 7.1.1 이항 산술 연산자

2개의 피연산자를 산술 연산하여 숫자 값을 만든다.

**모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수 효과 (side effect)가 없다.** 언제나 새로운 값을 만들 뿐이다.

<img src= "https://github.com/user-attachments/assets/0bfda1ee-88af-46f3-b584-266c69506795" width=350/>

```jsx
5 + 2 // 7
5 - 2 // 3
5 * 2 // 10
5 / 2 // 2.5
5 % 2 // 1
```

### 7.1.2 단항 산술 연산자

1개의 피연산자를 산술 연산하여 숫자 값을 만든다.

<img src= "https://github.com/user-attachments/assets/f2126e62-633f-483b-9157-c77cf531901b" width=350/>

**증가/감소(++/—) 연산자**는 피연산자의 값을 변경하는 **부수 효과가 있다.** 다시 말해, 증가/감소 연산을 하면 피연산자의 값을 변경하는 **암묵적 할당**이 이뤄진다.

```jsx
var x = 1;

// ++ 연산자는 암묵적 할당이 이뤄진다.
x++; // x = x + 1
console.log(x) // 2
```

**+단항 연산자**는 피연산자에 **어떠한 효과도 없다.** 숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 **숫자 타입으로 변환하여 반환**한다. 이때 피연산자를 변경하는 것이 아니라 숫자 타입으로 반환한 **값을 생성해서 반환**한다.

```jsx
var x = "1";

console.log(+x) // 1
console.log(x) // "1" , 부수 효과는 없다

x = true
console.log(+x) // 1
console.log(x) // true

x = false
console.log(+x) // 0
console.log(x) // false

x = "hello"
console.log(+x) // NaN
console.log(x) // "hello"
```

**-단항 연산자**는 **부호를 반전**한 값을 반환한다. + 단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자에 사용하면 **숫자 타입으로 변환**한다.

```jsx
// 부호 반전
-(-10); // 10

// 숫자 타입으로 변환
-"10" // 10

// 불리언 값을 숫자로 타입 변환
-true // -1
```

### 7.1.3 문자열 연결 연산자

+연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

```jsx
// 문자열 연결 연산자
'1' + 2 // "12"
1 + '2' // "12"

// 산술 연산자
1 + 2 // 3

// true는 1로 타입 변환
1 + true // 3

// false는 0으로 타입 변환
1 + false // 1

// null은 0으로 타입 변환
1 + null // 1

1 + undefined // NaN
```

자바스크립트 엔진에 의해 암묵적으로 타입이 변환되기도 한다. 위 예제에서 true를 1로 변환하는 것 처럼말이다. 이를 **암묵적 타입 변환**, **타입 강제 변환**

---

# 7.2 할당 연산자

할당 연산자는 좌항의 변수에 값을 할당하므로 변수 값이 변하는 **부수 효과가 있다.**

<img src= "https://github.com/user-attachments/assets/1cec07b8-a1de-4fae-8d74-365d9e5b56d0" width=350/>

할당무은 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다. 하지만 **할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.** 이러한 특징을 활용해 여러 변수에 동일한 값을 연쇄 할당할 수 있다.

```jsx
var a,b,c

a = b = c = 0
```

---

# 7.3 비교 연산자

### 7.3.1 동등/일치 비교 연산자

동등 비교, 일치 비교 연산자는 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환한다. **동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다.**

**동등 비교(==) 연산자는 좌항과 우항을 비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.** 좌항과 우항의 피연산자의 타입은 다르더라도 암묵적 타입 변환 후 같은 값을 가질 수 있다면 true를 반환한다.

```jsx
// 동등 비교
5 == 5; // true

5 == "5" // true
```

동등 비교 연산자는 편리한 경우도 있찌만 결과를 예측하기 어렵고 실수하기 쉽다.

- 아래 코드는 안티 패턴이므로 이해하지 않아도 된다.

```jsx
"0" == "" // false
0 == '' // true
0 == "0" // true
false == "false" // false
false = "0" // true
```

- 이처럼 동등 비교 연산자는 에측하기 어려운 값을 만들어 내기 때문에 사용하지 않는 편이 좋다.

**일치 비교( ===)** 연산자는 **좌항과 우항이 타입도 같고 값도 같은 경우 true**를 반환한다.

```jsx
// 일치 비교
5 === 5 // ture

5 === "5" // false
```

일치 비교 연산자에서 주의할 것은 **NaN**이다.

```jsx
NaN === NaN // **false**
```

**NaN은 자신과 일치하지 않는 유일한 값**이다.  NaN인지 조사하려면 빌트인 함후 Number.isNaN을 사용한다.

```jsx
Number.isNaN(NaN) // true
Number.isNaN(10) // false
Number.isNaN(1 + undefined) // true
```

숫자 0도 주의, 자바스크립트에서는 양의 0과 음의 0이 있는데 이를 비교하면 true가 나온다.

```jsx
0 === -0 // true
0 == -0 // true
```

- **Object is** 메서드
    - 동등 비교 연산자와 일치 비교 연산자는 +0과 -0을 동일하다고 평간한다. 또한 NaN이 다른 값이라 평가한다.
    - **Object.is** 메서드는 **예측 가능한 정확한 비교 결과를 반환**한다.
    
     
    
    ```jsx
    -0 === +0 // true
    Object.is(-0,+0) // false
    
    NaN === NaN ; // false
    Object.is(NaN,NaN) // true
    ```
    

---

# 7.4 삼항 조건 연산자

조선식의 평가 결과에 따라 반활 값을 결정한다. 유일한 삼항 연산자이며, 부수 효과는 없다.

```jsx
var result = **score >= 60 ? "pass" : "fail"**
```

```jsx
var x = 2;

// 2 % 2는 0이고, 0은 false로 암묵적 타입 변환된다.
var result = x % 2 ? "홀수" : "짝수";

console.log(result) // 짝수
```

`if … else 문`을 사용해도 삼항 조건 연사자 표현식과 유사하게 처리할 수 있다.

```jsx
var x = 2, result;

if ( x % 2 ) result = '홀수';
else result = "짝수";

console.log(result)
```

하지만 삼항 조건 연산자 표현식은 if … else문과는 중요하한 차이가 있다. **삼항 조건 연산자느 값처럼 사용할 수 있지만, if … else 문은 값처럼 사용할 수 없다.** 

**if … else 문은 표현식이 아닌 문**이다. 따라서 값처럼 사용할 수 없다.

조건에 따라 **어떤 값을 결정하는 경우 삼항 조건 연산자 표현식을 사용하는 편이 유리**하다. 하지만 조건에 따라 **수행해야할 문이 여러 개라면 if …else 문의 가독성이 더 좋다.**

---

# 7.5 논리 연산자

<img src= "https://github.com/user-attachments/assets/c379ea8d-160e-4de2-a20a-dd2c8d1d5465" width=350/>

**논리 부정(!)** 연산자는 **언제나 불리언 값을 반환**한다. 피연산자가 반드시 불리언 값일 필요는 없다. 만약 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환한다.

```jsx
// 암묵적 타입 변환
!0; // true
!"hello" // false

!!0 // false ( 자기 자신의 원래 값으로 평가 됨 )
```

**논리합(||)** 또는 **논리곱(&&**) 연산자 표현식**의 평가 결과는 불리언 값이 아닐 수 도 있다**. 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 **피연산자 중 어느 한쪽으로 평가**된다.

```jsx
// 단축 평가
"Cat" && "Dog" // Dog
```

---

# 7.6 쉼표 연산자

쉼표 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝마녀 마지막 피연산자의 평가 결과를 리턴한다.

```jsx
var x,y,z;

x = 1, y = 2, z = 3; // 3
```

---

# 7.7  그룹 연산자

소괄호로 피연산자를 감싸는 그룹 연산자는 **자신의 표현식을 가장 먼저 평가**한다. 따라서 연산자의 우선순위를 조절할 수 있다. **그룹 연산자는 우선순위가 가장 높다.**

```jsx
10 * 2 + 3 // 23

10 * ( 2 + 3 ) // 50
```

---

# 7.8 typeof 연산자

피연사자의 **데이터 타입을 문자열로 반환**한다.

**“string”,”number”,”undefined”,”symbol”,”object”,”function”** 중 하나를 반환한다.

<img src= "https://github.com/user-attachments/assets/66c35df8-7c6e-4d2d-87a3-9b23b7881b7c" width=350/>

**typeof 연산자로 null 값을 연산**하면 “null”이 아닌 **“object”를 반환**한다는데 주의하자. 이것은 자바스크립트의 버그다.

따라서 null 타입인지 확인할 때는 일치 연산자 ( === )를 사용하자

---

# 7.9 지수 연산자

ES7에서 도입된 지수 연산자는 좌항의 피연사자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다.

```jsx
2 ** 2 // 4
2 ** 2.5 // 5.5665...
2 ** 0 // 1
2 ** -2 // 0.25
```

지수 연산자가 **도입되기 이전**에는 **Math.pow 메서드**를 사용했다.

```jsx
Math.pow(2,2)
Math.pow(2,2.5)
Math.pow(2,0)
Math.pow(2,-2)
```

**음수를 거듭제곱의 밑**으로 사용해 계산하려면 아래와 같이 **괄호로 묶어야 한다.**

```jsx
-5 ** 2 // SyntaxError

**(-5)** ** 2 // 25
```

지수 연산자는 다른 산술 연산자와 마찬가지로 **할당 연산자와 함께 사용할 수 있다.**

```jsx
var num = 5;
num **= 2; // 25
```

지수 연산자는 **이항 연산자** 중에서 **우선수위가 가장 높다.**

```jsx
2 * 5 ** 2// 50
```

---

# 7. 10 그 외의 연산자

<img src = "https://github.com/user-attachments/assets/b468b525-3681-4e59-95b7-1855f3c666a8" width=350/>
---

# 7. 11 연산자의 부수 효과

대부분의 연산자는 다른 코드에 영향을 주지 않는다. 부수 효과가 있는 연산자는 **할당 연사자 ( = ), 증가/ 감소 연산자( ++ / —), delete 연산자다.**
