# 11장: 원시 값과 객체의 비교
> 원시 타입(primitive type)의 값(원시 값)은 변경 불가능한 값(immutable value)다.<br>
> 객체(참조) 타입(object/reference type)의 값은 변경 가능한 값(mutable value)이다.
> ***
> 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다.<br>
> 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.
> ***
> 값에 의한 전달(pass by value): 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다.<br>
> 참조에 의한 전다(pass by reference): 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다.

## 11.1 원시 값
### 11.1.1 변경 불가능한 값
> 원시 타입(primitive type)
> ***
> 원시 값은 변경 불가능한 값(immutable value)이다.
> ***
> 한번 생성된 원시 값은 읽기 전용(read only) 값으로서 변경할 수 없다.
> * 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술

###### 예제 11-01 : 원시 타입의 불변성(immutability)
> 원시 값은 변경 불가능한 값이기에 값을 직접 변경할 수 없다.<br>
> 변수 값을 변경하기 위해 원시 값을 재할당한다면<br>**새로운** 메모리 공간을 확보하고<br>재할당한 값을 저장한 이후,<br>변수가 참조하던 메모리 공간의 **주소를 변경**한다.
> ***
> Point: 불변성을 갖는 원시 값을 할당한 변수는 재할당으로만 변수 값을 변경할 수밖에 없다.
```Javascript
const o = {}; // const 키워드를 통해 선언한 변수는 재할당 금지. 상수 = 재할당 금지 변수

o.a = 1; // (1) const 키워드로 선언한 변수에 할당한 원시 값(상수)는 변경 불가
// (2) const 키워드로 선언한 변수에 할당한 객체는 변경할 수 있다.
console.log(o); // {a: 1}
```

### 11.1.2 문자열과 불변성

> 원시 값인 문자열은 다른 원시 값과 비교할 때 독특한 특징이 있다.
> ***
> 문자열 = 0개 이상의 문자(character)로 이뤄진 집합
> * 1개의 문자는 2바이트의 메모리 공간에 저장된다.
> * 문자열의 경우 1개의 문자로 이뤄진 문자열은 2바이트,<br>10개의 문자로 이뤄진 문자열은 20바이트가 필요<br>(실제와는 다르지만 단순하게 계산했을 때 상정)
>   * 숫자 값은 1도, 1000000도 동일한 8바이트가 필요

###### 예제 11-02: 문자열은 0개 이상의 문자로 이뤄진 집합
```Javascript
var str1 = ''; // 0개의 문자로 이루어진 문자열 = 빈 문자열
var str2 = 'Hello'; // 5개의 문자로 이루어진 문자열
```

###### 예제 11-03: Javascript의 문자열은 원시 타입이며, 변경 불가능하다<br>(즉, 생성 이후에 변경x)
* Javascript는 개발자 편의를 위해 **원시 타입**인 문자열 타입을 제공

```Javascript
var str = 'Hello'; // (1) 문자열 'Hello' 생성 
// (2) 식별자 str은 문자열 'Hello'가 저장된 메모리 공간의 첫 번째 메모리 셀 주소를 가리킴
str = 'world'; // (3) 새로운 문자열 'world'를 메모리에 생성 (4) 식별자 str은 이것을(주소를) 가리킨다
// 그러므로 이때 'Hello'와 'world'는 모두 메모리에 존재한다.
```

* 문자열은 **유사 배열 객체**이면서 이터러블(iterable(이므로 배열과 유사하게 각 문자에 접근 가능하다

> 유사 배열 객체(array-like object)
> ***
> 마치 배열처럼 인덱스로 프로퍼티 값에 접근 가능하고 length 프로퍼티를 갖는 객체
> * (예) 문자열
>   1. 마치 배열처럼 인덱스로 각 문자에 접근 가능
>   2. length 프로퍼티 가짐
>   3. for문으로 순회도 가능
> ##### 예제 11-04
> ```Javascript
> var str = 'string';
> console.log(str[0]); // 문자열 = 유사 배열 // 인덱스로 각 문자 접근 가능
> 
> // 원시 값인 문자열이 객체처럼 동작
> console.log(str.length); // 6
> console.log(str.toUpperCase()); // STRING
> ```
> * 원시 값을 객체처럼 사용하면 원시 값을 감싸는 **래퍼(wrapper)** 객체로 자동 변환됨

###### 예제 11-05
```Javascript
var str = 'string';
str[0] = 'S'; // (유사배열)접근은 가능해도 (원시 값)변경은 안 됨 -> 변경이 안 돼도 에러X
console.log(str); // (그대로) string
```

> 원시 값은 어떤 일이 있어도 불변하기에 예기치 못한 변경으로부터 자유로움 = 데이터의 신뢰성 보장

### 11.1.3 값에 의한 전달

###### 예제 11-06: 변수에 원시 값을 갖는 변수를 할당하면?
```Javascript
var score = 80;
var copy = score;  // 할당받는 변수(copy)에는 할당되는 변수(score)의 원시 값이 복사되어 전달됨

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // ?
```

###### 예제 11-07: 값에 의한 전달 - 메모리는 별개의 공간, type&value는 동일
> 값에 의한 전달 대신 <b>공유에 의한 전달(pass by sharing)</b>이라고 표현할 때도 있다.

```Javascript
var score = 80;
var copy = score;
console.log(score, copy); // 80 80 
console.log(score === copy); // true
```
* score 변수와 copy 변수는 type, value는 동일
* 하지만 둘의 값 80은 별도의 메모리 공간에 저장된 **별개의 값**

###### 예제 11-08: 예제 11-07에서 score변수의 값을 이후에 변경한다면?
```Javascript
var score = 80;
var copy = score;
console.log(score, copy); // 80 80
console.log(score === copy); // true

score = 100; // score변수와 copy변수 값은 다른 메모리 공간에 저장된 별개의 값이기에,
// score 변수의 값을 변경해도 copy 변수의 값에는 아무런 영향도 X

console.log(score, copy); // 100, 80
console.log(score === copy); // false
```

* 엄격하게 표현하면, 변수에는 값이 아니라 **메모리 주소**가 전달됨
  * 식별자는 값이 아니라 메모리 주소를 기억함<br>(식별자 = 메모리 주소에 붙인 이름)
  * 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있음

###### 예제 11-09

```Javascript
var x = 10; // 할당 연산자는 숫자 리터럴 10에 의해 생성된 숫자 값 10이 저장된 메모리 공간의 주소를 전달한다. 
// 이로써 식별자 x는 메모리 공간에 저장된 숫자 값 10을 식별할 수 있다.
```

###### 예제 11-10
```Javascript
var copy = score; // score는 식별자 표현식으로서 숫자 값 80으로 평가됨
```
* 평가 방식
  1. 새로운 80을 생성(복사)해서 메모리 주소를 전달
     * 할당 시점에 두 변수가 기억하는 메모리 주소가 다름
     * → 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 **별개**의 값이 됨<br>= 어느 한쪽이 변경되더라도 서로 간섭 X
  2. score 변수값 메모리 주소를 그대로 전달
     * 할당 시점에 두 변수가 기억하는 메모리 주소가 같음 

## 11.2 객체

1. 프로퍼티 개수 미정
2. 동적으로 추가/삭제 가능
3. 프로퍼티 값에 제약 없음: 원시 값처럼 확보할 메모리 공간 크기를 사전에 정할 수 없음
4. 객체 생성 & 프로퍼티 접근시 원시 값보다 비용이 많이 드는 편

###### 자바스크립트 객체의 관리 방식: 자바스크립트 객체 = 프로퍼티 키를 인덱스로 사용하는 해시 테이블
* 자바스크립트는 클래스 없이 객체 생성 가능
* 객체 생성 이후에도 동적으로 프로퍼티, 메서드 추가 가능
* 클래스 기반 객체지향 프로그래밍 언어와 비교했을 때 사용감은 더 낫고 성능은 뒤떨어짐
    * 그래서 V8 자바스크립트 엔진에서는 프로퍼티 접근시 동적 탐색 대신 히든 클래스 방식을 사용, 성능 보완

### 11.2.1 변경 가능한 값
> 객체(참조) 타입 값 = 객체 = 변경 가능한 값(mutable value)

###### 예제 11-11: 변수에 객체를 할당했을 때, 무슨 일이 일어날까?
```Javascript
var person = {
    name: 'Lee'
};
```

1. 객체 할당 변수가 기억하는 메모리 주소
2. 를 통해 메모리 공간에 접근하면
3. 참조 값(reference value)에 접근 가능
   * ***참조 값 = 생성된 객체가 저장된 메모리 공간의 주소 그 자체***
4. 이렇게 실제 객체에 접근 가능

###### 예제 11-12
```Javascript
var person = {
    name: 'Lee' // 할당이 이뤄지는 시점에 객체 리터럴 해석 & 객체 생성
};

console.log(person); // {name: "Lee"} // person 변수에 저장된 참조값으로 실제 객체에 접근
```

* 객체를 할당한 변수는 **재할당 없이** 객체를 **직접 변경**할 수 있다.
  * 그 말인즉슨 **재할당 없이** 프로퍼티 동적으로 *추가* 가능
  * 프로퍼티 값 *갱신* 가능
  * 프로퍼티 자체 *삭제*도 가능

###### 예제 11-12
```Javascript
var person = {
    name: 'Lee' // 할당이 이뤄지는 시점에 객체 리터럴 해석 & 객체 생성
};

person.name = 'Kim'; // 프로퍼티 값 갱신
person.address = 'Seoul'; // 프로퍼티 동적 생성
console.log(person); // {name: "Kim", address: "Seoul"}
```

* 객체 구조에 따른 부작용: ***여러 개의 식별자가 하나의 객체 공유 가능***

###### 얕은 복사(shallow copy)와 깊은 복사(deep copy)
* 일단 복사를 했으니까 새로 생성된 객체는 원본과 다름
* 하지만 **얕게** 복사를 하면 참조값을 복사
* **깊게** 복사를 하면 객체까지 모두 복사 = 원시 값처럼 완전한 복사본 만든 꼴
***
* 깊은 복사: 원시 값을 할당한 변수를 다른 변수에 할당
* 얕은 복사: 객체를 할당한 변수를 다른 변수에 할당


### 11.2.2 참조에 의한 전달

> 참조에 의한 전달: 원본의 참조 값이 복사되어 전달되는 것

###### 예제 11-16, 11-17
```Javascript
var person = {
    name: 'Lee'
};

var copy = person; // 참조 값을 복사: 얕은 복사(저장된 메모리 주소는 다르지만 동일한 참조 값, 즉 두 개의 식별자가 하나의 객체를 공유)

console.log(copy === person); // true // copy와 person은 동일한 객체를 참조하기 때문

copy.name = 'Kim';
person.address = 'Seoul';

// 양쪽 다 변해버림
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy);// {name: "Kim", address: "Seoul"}
```

* 값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일
* 자바스크립트에는 참조에 의한 전달은 존재하지 않고 값에 의한 전달만이 존재한다고 말할 수 있음

###### 예제 11-18: Quiz
```Javascript
var person1 = {
    name: 'Lee'
};

var person2 = {
    name: 'Lee'
};

// === 일치 비교 연산자는 변수에 저장되어있는 값을 타입 변환하지 않고 비교함(타입도 비교함)
console.log(person1 === person2); // (1)번
console.log(person1.name === person2.name); // (2)번
```

* Answer
    1. person1, person2  변수는 값만 같고 저장된 메모리가 달라서 별개의 객체다. 즉 false
    2. property value를 참조하는 person1.name과 person2.name은 값으로 평가될 수 있는 표현식이며, 둘 다 "원시 값" 'Lee'로 평가, 따라서 true 