# 11장: 원시 값과 객체의 비교

총 3가지로 분류할 수 있다

- 원시타입 값 : immutable(변경 불가능) / 객체타입 값 : mutable(변경 가능)
- 원시 값을 변수에 할당할 시 `실제 값` 저장 / 객체 타입은 변수에 `참조 값`이 저장
- 원시 값을 다른 변수에 할당하면 `원본의 원시 값`이 `복사`되어 전달 / 객체 타입은 원본의 `참조 값이 복사`되어 전달

## 11.1 원시 값

immutable이라는 의미가 무엇인가?

- 값 자체를 변경할 수 없다는 것이다.

뭔 말인지 모르니 예시를 보는 것이 낫겠다

아래 챕터를 이어나가 예시를 보는 것이 낫겠다

### 11.1.1 변경 불가능한 값

139p 사진

즉, 불변성이라고하면 원시 값을 재할당 시 해당 메모리 공간의 값이 바뀌는 것이 아니고, 새로운 메모리 공간에 값을 만들어서 이를 참조하게 하는 것이다

그렇기에 불변 값이라고 부르는 것으로 보인다

### 11.1.2 문자열과 불변성

문자열은 1개의 문자를 단순하게 `2바이트`로 표현한다

단순 숫자 타입은 1이든 100,000이든 동일한 8바이트가 필요하다

그렇기에 문자열이 많다면 그만큼 메모리를 많이 먹는다는 뜻이기도 하다

문자열도 마찬가지로 불변성이고, 재할당 시 새로운 메모리 공간을 차지한다.

추가적으로 문자열은 `유사 배열 객체`로 부르는데, 아래의 예시를 보자

```
var str = 'string'
console.log(str[0]) // s, 배열처럼 접근이 가능하다
str[0] = '!'
console.log(str) // string -> 원시 값이기에 변경이 안된다

// 읽기 전용값이라고 보면 된다
```

### 11.1.3 값에 의한 전달

```
var score = 10
var copy = score

score = 100
console.log(score) // 100
console.log(copy) // 10
```

복사되어 값이 바뀔 것 같지만, 100이라는 `새로운 값`이 만들어져 새로운 메모리 공간에 할당되어 copy에서 새로운 것을 참조한다

그렇기에 score를 바꾸어도 copy에서도 안바뀌는 것

왜그러냐면 `불변성`을 가지기 때문이다

144p 사진

> 두 변수의 원시 값은 `서로 다른 메모리 공간`에 저장된 별개의 값이 된다

## 11.2 객체

- 객체는 프로퍼티 개수 제한도 없고 동적으로 추가, 삭제가 가능하다

그렇기에 메모리 공간의 크기를 사전에 정할 수 없다

그렇기에 다른 언어들에 비해 자유롭지만 성능 면에서는 비효율적일 수 있다

그렇기에 이를 최적화하기 위해 `히든 클래스`라는 방법을 사용한다

-> 추후 알아보도록 하자.. 이후 정리 예정

### 11.2.1 변경 가능한 값

- 참조 값 : 생성된 객체가 저장된 메모리 공간의 주소 그 자체

재할당 없이 객체를 직접 변경할 수 있으며 프로퍼티를 동적으로 `추가 및 삭제, 갱신`이 자유롭다

```
var person = {
  name: 'yang'
}

person.name = 'kim'
person.age = 20

console.log(person) // { name: 'kim', age: 20 }
```

149p 사진

### 11.2.2 참조에 의한 전달

- 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 의미와 비슷하다

즉, 참조 값이 복사되어 전달 === 참조에 의한 전달

151p 그림

```
var person = {
  name: 'Lee'
}

var copy = person

copy.name = 'kim'
person.age = 20

console.log(person) // { name: 'kim', age: 20 }
console.log(copy) // { name: 'kim', age: 20 }
```
