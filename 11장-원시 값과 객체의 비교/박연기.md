![image](https://github.com/user-attachments/assets/0fe6cd9a-32bd-462f-8f18-60627fec20f2)자바스크립트에서의 타입은 크게 **원시 타입과** **객체 타입**으로 구분할 수 있다.

원시 타입과 객체 타입은 크게 세 가지 측면에서 다르다

1. **원시 값**은 **변경 불가능**한 값이다. **객체**는 **변경 가능**한 값이다.
2. **원시 값**을 변수에 할당하면 **실제 값이 저장**된다. **객체**를 변수에 할당하면 **참조값이 저장**된다.
3. **원시 값을 갖는 변수**를 **다른 변수에 할당**하면 원본의 **원시 값이 복사되어 전달**된다. 이를 **값에 의한 전달**이라 한다. 이에 반해 **객체**는 **참조 값이 복사**되어 전달된다. 이를 **참조에 의한 전달**이라 한다.

---

# 11.1 원시값

### 변경 불가능한 값

원시 타입의 값, 즉 **원시 값은 변경 불가능한 값**이다. 변수와 값은 구분해서 생각해야 한다. **변수**는 하나의 **값을 저장하기 위해** 확보한 메모리 공간 자체 또는 **메모리 공간을 식별하기 위해 붙인 이름**이고, **값**은 **변수에 저장된 데이터**로서 **표현식이 평가되어 생성된 결과**를 말한다. 변경 불가능하다는 것은 **변수가 아니라 값에 대한 진술**이다.

즉 “원시 값은 변경 불가능하다”는 원시 값 자체를 변경할 수 없다는 것이지 변수 값을 변경할 수 없다는 것이 아니다.

이러한 특징 때문에 원시 값은 데이터의 **신뢰성을 보장**한다.

원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 **값을 변경하는 것이 아니라** 새로운 메모리 공간을 확보후 **새로운 원시 값을 저장후 변수는 새롭게 생긴 메모리 값을 가르킨다**. 이때 변수가 **참조하던 메모리 주소가 바뀐다.**

<img src="https://github.com/user-attachments/assets/8680a2e8-fd81-4cc3-b23e-35ed3edc499f" width=400 />

원시 값의 이러한 특성을 **불변성**이라 한다.

불변성을 갖는 원시 값을 할당할 변수는 **재할당 이외에** 변**수 값을 변경할 수 있는 방법은 없다.**

### 11.1.2 문자열과 불변성

**원시 값을 저장**하려면 먼저 확보해야 하는 **메모리 공간의 크기를 결정**해야 한다. **문자열 타입( 2바이트 )**, **숫자 타입( 8바이트 )** 이외는 크기를 명확히 규정하고 있지 않아서 브라우저마다 크기가 다를 수 있다.

**문자열은** 몇 **개의 문자로 이뤄졌느냐**에 따라 필요한 **메모리 공간의 크기가 결정**된다. **숫자 값**은 1, 100000도 **동일한 8바이트**가 필요하지만, **문자열**의 경우 **1개의 문자열 2바이트**, **10개의 문자로 이뤄진 문자열은 20바이트**가 필요하다.

자바스크립의 문자열은 원시 타입이며, 변경 불가능하다. 이것은 문자열이 **생성된 이후에 변경할 수 없**음을 의미한다.

```tsx
var str = "hello";
str = "world";
```

첫 번째 문이 실행되면 메모리 공간에 “hello”가 생성되고 식별자 **str은 해당 메모리 주소를 가르킨다.** 

두번째 문이 실행되면 ‘world’를 **새로운 메모리 공간에 생성**하고 식별자 str은 이것을 가르킨다. 이때 문자열 **“hello”와 “world”는 모두 메모리에 존재**한다. 

이제 문자열의 한 문자를 변경해보자. **문자열은 유사 배열 객체**이면서 **이터러블** 이므로 배열과 유사하게 각 문자에 접근할 수 있다.

- 유사 배열 객체
    - **유사 배열 객체**는 마치 배**열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체**를 말한다. 문자열은 유사 배열 객체이고 for문으로 순회할 수 도 있다.
        
        ```tsx
        var str = "string";
        
        console.log(str[0]) // "s"
        ```
        

```tsx
var str = "string"
**// 문자열은 유사 배열이므로 인덱스를 사용해 각 문자에 접근 가능**
**// 문자열은 원시값이므로 변경할 수 없다. 이때 에러 발생하지 않는다.**
str[0] = "ABC"

consol.log(str) // string
```

`str[0] = "ABC"` 처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다. 문자열은 변경 불가능한 값이기 때문이다. 이때 **에러를 발생하지 않고 해당 문은 무시된다.**

변수에 새로운 문자열을 재할당하는 것은 물론 가능하다. 

### 11.1.3 값에 의한 전달

```tsx
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score) // 100
console.log(copy) // 80
```

`copy = score`에서 score는 값 80으로 평가되므로 **copy 변수에도 80이 할당**된다. 이때 새로운 숫자 값 80이 생성되어 copy에 할당된다.

변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수( copy )에는 할당되는 변수( score )의 원시 값이 **복사되어 전달**된다. 이를 **값에 의한 전달**이라 한다.

하지만 **score 변수**와 **copy 변수**의 **값 80은** 다른 **메모리 공간에 저장된 별개의 값**이다.

<img src="https://github.com/user-attachments/assets/121ff082-38bc-4de6-b4b8-cb28d94dfe2b" width=400 />

따라서 score 변수의 값을 변경해도 copy 변수의 값에는 **어떠한 영향도 주지 않는다.**

<img src="https://github.com/user-attachments/assets/6bbf357f-8ea1-4198-a76a-87c60e881958" width=400 />

위 그림에서는 변수에 원시 값을 갖는 변수를 할당하면 **원시 값이 복사되는 것으로 표현**했다. 하지만 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 **변수가 같은 원시 값을 참조**하다가 어느 한쪽의 **변수에 재할당이 이뤄졌을 때 비로소 새로운 공간에 저장하도록 동작**할 수도 있다. **파이썬은 이처럼 동작**한다

<img src="https://github.com/user-attachments/assets/a4c1535d-b827-4ecd-beeb-fa45500108be" width=400 />
“값에 의한 전달”이라는 용어는 오해가 있을 수도 있다. 엄격하게 표현하면 **변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달**되기 때문이다. 이는 **변수와 같은 식별자는** 값이 아니라 **메모리 주소를 기억**하고 있기 때문이다.

식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야 하므로 변수와 같은 **식별자는 값이 아니라 메모리 주소를 기억하고 있다**.

```tsx
var x = 10;
```

할당 연산자는 숫자 리터럴 10에 의해 생성된 숫자 값 10이 저장된 메모리 공간의 주소를 전달한다. 식별자 x는 메모리 공간에 저장된 숫자값 10을 식별할 수 있다.

이처럼 **“값의 의한 전달”**도 사실은 값을 전달하는 것이 아니라 **메모리 주소를 전달**한다. 단, 전달된 메모리 주소를 통해 **메모리 공간에 접근하면 값을 참조할 수 있다.**

중요한 것은 두 **변수의 원시 값은 서로 다른 메모리 공간에 저장**된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 **서로 간섭할 수 없다.**

---

# 11.2 객체

객체는 원시값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다. 객체를 관리하는 방식이 복잡하고 구현 방식도 브라우저마다 다를 수 있다. 객체를 생성하고 프로퍼티에 접근하는 것은 비용이 많이 드는 일이다. 따라서 객체는 원시값과 다른 방식으로 동작하도록 설계되었다.

- 자바스크립트 객체의 관리 방식
    - 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라 생각할 수 있다.
        
       <img src="https://github.com/user-attachments/assets/e349ed3d-f0b4-4774-b8da-242d3616011c" width=400 />
        
    - 자바스크립트는 클래스 없이 객체를 생성할 수 있으며 객체가 생성된 후에 동적으로 프로퍼티와 메서드를 추가할 수 있다. 이는 매우 편리하지만 프로퍼티 접근에 비용이 많이 드는 비효율적인 방식이다.
    - 따라서 크롬에서 사용하는 V8 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 대신에 히든 클래스라는 방식을 사용해 성능을 향상시킨다.

### 11.2.1 변경 가능한 값

객체 타입의 값, 즉 **객체는 변경 가능한 값**이다.

객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조 값에 접근할 수 있다.** 참조 값은 생성된 객체가 저장된 메모리 공간의 주소다.

객체를 할당한 변수에는 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장되어 있다. 이를 참조값이라 한다.

<img src="https://github.com/user-attachments/assets/72214989-ec7b-480e-8a4b-b83f530aa1f2" width=400 />
객체를 할당한 변수를 참조하면 메모리에 저장된 **참조 값을 통해 실제 객체에 접근**한다.

```tsx
var person = {
	name : "Lee"
};

console.log(person); // {name :Lee}
```

원시 값을 갖는 변수의 경우 “변수는 0값을 갖는다” 또는 “변수의 값은 0다”라고 표현 한다. 하지만 객체를 할당한 변수의 경우 **“변수는 객체를 참조하고 있다.”** 또는 **“변수는 객체를 가리키고 있다”**라 표현한다.

객체는 변경 가능한 값이다. 재할당 없이 **프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제**할 수도 있다.

```tsx
ver peson= {
	name : "Lee"
}

person.name = "Kim",
console.log(person) // {name : "Kim"}
```

객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 **변수의 참조값은 변경되지 않는다.**

메모리를 효율적으로 사용하기 위해, 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 **객체는 변경 가능한 값으로 설계되어 있다.**  객체는 이러한 **구조적 단점에 따른 부작용이** 있다. 그것은 **여러 개의 식별자가 하나의 객체를 공유**할 수 있다.

- 얕은 복사
    - 객체를 프로터피 값으로 갖는 객체의 경우 **얕은 복사**는 **한 단계까지만 복사**하는 것을 말하고 **깊은 복사**는 **객체에 중첩되어 있는 객체까지 모두 복사**하는 것을 말한다.
        
        ```tsx
        const o = {x : { y : 1 }};
        
        // 얕은 복사
        const c1 = {...o} 
        console.log(c1 === o) // false
        console.log(c1.x === o.x) // true
        
        // lodash의 cloneDeep을 이용한 깊은 복사
        const _ = require("lodash");
        // 깊은 복사
        const c2 = _.cloneDeep(o);
        console.log(c2 === o) // false
        console.log(c2.x === o.x) // false
        ```
        
    - 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체다. 하지만 얕은 복사는 중첩되어 있는 객체의 경우 참조 값을 복사한다.
    - 참고로 원시값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사, 객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사라고 부르는 경우도 있다.

### 11.2.2 참조에 의한 전달

```tsx
var person ={
	name : "Lee"
}

// 참조 값을 복사(얕은 복사)
var copy = person
```

객체를 가리키는 변수 ( person )을 다른 변수에 할당하면 **참조 값이 복사되어 전달**된다. 이를 참**조에 의한 전달**이라 한다.

<img src="https://github.com/user-attachments/assets/9df464a3-6b70-4c56-bbf7-4b89f0b3c41d" width=400 />
원본 person과 사본 copy는 모두 동일한 객체를 가르킨다. **두 개의 식별자가 하나의 객체를 공유한다**는 의미다. 따라서 원본 또는 사본 중 **어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.**

```tsx
var person = {
	name : "Lee"
}
// 참조 값을 복사(얕은 복사)
var copy = person;

// copy와 person은 동일한 객체를 참조
console.log(person === copy) // true

copy.name = "Kim"

person.addr = "Seoul"

console.log(person) // {name : "Kim",addr:"Seoul"}
console.log(copy) // {name : "Kim",addr:"Seoul"}
```

결국 **“값에 의한 전달”**과 **“참조에 의한 전달”**은 식별자가 기억하는 **메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일**하다. 다만 변수에 저장되어 있는 값이 **원시 값이나 참조 값이냐의 차이만 있을 뿐**이다. 따라서 자바스크립트에서는 “**참조에 의한 전달”은 존재하지 않고 “값에 의한 전달” 만이 존재한다고 말할 수 있다.**
