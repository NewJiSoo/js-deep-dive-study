# 14장 전역 변수의 문제점

전역 변수의 무분별한 사용은 위험하기에 최소화 시키는 방법을 알아본다

## 14.1 변수의 생명 주기

### 14.1.1 지역 변수의 생명 주기

변수는 선언으로 생성과 할당을 통해 값을 갖고, 언젠가 소멸한다.

즉, `생명 주기`가 존재한다

변수 선언은 선언문이 어디에 있든 상관 없이 가장 먼저 실행된다.

201p 사진

> 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다

### 14.1.2 전역 변수의 생명 주기

전역 코드에는 반환문을 사용할 수 없기에 마지막 문이 실행되어

더 이상 실행할 문이 없을 때 종료한다

203p 그림

## 14.2 전역 변수의 문제점

1. 암묵적 결합
   - 어디서든 참조하기에 변경할 수 있는 것을 허용한다. 그렇기에 의도치 않은 상태 변화가 일어날 수 있다
2. 긴 생명 주기
   - 생명 주기가 길기에 메모리 리소스도 오랜 기간 소비한다
3. 스코프 체인 상에서 종점에 존재
   - 말 그대로 전역 변수의 검색 속도가 가장 느리다. 상위까지 찾아 나서야 하기 때문이다
4. 네임스페이스 오염
   - 파일이 나뉠 때 전역 스코프 공유할 때 예상치 못한 문제점을 가져온다

## 14.3 전역 변수의 사용을 억제하는 방법

변수의 스코프는 좁을 수록 좋다.

### 14.3.1 즉시 실행 함수

- 즉시 실행 함수로 감싸면 해당 함수의 지역 변수가 된다.

### 14.3.2 네임스페이스 객체

```
var MYAPP = {}

MYAPP.name = 'lee'
```

네임 스페이스를 담당할 객체를 생성하여 프로퍼티를 추가하는 방법

### 14.3.3 모듈 패턴

- 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다

```
var Counter = (function() {
  var num = 0 // private 변수
  return {
    increase() {
      return ++num
    },
    decrease() {
      return --num
    }
  }
}())

console.log(Counter.num) // undefined
console.log(Counter.increase()) // 1
console.log(Counter.increase()) // 2
console.log(Counter.decrease()) // 1
```

해당 내용은 클로저를 기반으로 하기에 변수를 가지고 있다

클로저는 추후 다룰 예정

### 14.3.4 ES6 모듈

```
<script type="module" src="lib.mjs"></script>
```

저렇게 type="module"을 쓰면 독자적인 모듈 스코프를 제공하며, 전역 변수를 사용할 수 없다
