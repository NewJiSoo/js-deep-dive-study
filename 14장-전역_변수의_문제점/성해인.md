# 14. 전역 변수의 문제점
> Q. 전역 변수의 **무분별한** 사용은 위험하다??
> <br>필수가 아니면 전역 변수 대신 지역 변수를 사용해야 하는 이유와 그 방법을 알아보자

<br>

## 14.1 변수의 생명 주기

### 14.1.1 지역 변수의 생명 주기

> 변수에는 생명 주기(life cycle)가 있다: 생명 주기가 없다면 한번 생성된 변수는 프로그램 종료 전까지 계속 메모리 공간을 점유한다.
> 1. 메모리 공간 확보(allocate)
> 2. 메모리 공간 해제(release)
> 3. 가용 메모리 풀(memory pool)에 반환
> ***
> * ***변수는 자신이 등록된 스코프가 소멸(메모리 해제)될 때까지 유효함*** 
> * 전역 변수의 생명 주기 = 애플리케이션의 생명 주기
> * (함수 내부)지역 변수의 생명 주기 = (대체로)해당 함수의 생명 주기(함수가 호출되면 생성, 함수가 종료되면 소멸)
>   * 지역 변수가 함수보다 오래 생존하는 경우도 있는데, 해당 변수 생성&등록 스코프를 다른 곳에서 참조하는 경우

#### 그림 14-1: 지역 변수의 생명 주기
![image](https://github.com/user-attachments/assets/5ae5d773-5d9d-4535-8fa0-bdc188f73e2a)




### 예제 14-01
```Javascript
function foo() {
    var x = 'local'; // 지역변수 x 는 foo 함수 호출 전까지는 생성X // 함수 호출X면 함수 내부 변수 선언문도 실행X
    console.log(local); // local
    return x;
}
foo();
console.log(x); // ReferenceError: x is not defined
```
> > 변수 선언은 선언문이 어디에 있든 상관없이 가장 먼저 실행되고, 런타임 이전 단계에서 자바스크립트 엔진에 이해 이루어진다
> 
> 위의 설명은 **전역 변수에 한정**된 것
> <br>함수 내부에서 선언한 변수는 함수 호출 직후, 함수 몸체 코드 한 줄씩 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행됨


### 예제 14-02: Quiz - (1)에서 출력되는 값은 무엇일까?
```Javascript
var x = 'global';
function foo() {
    console.log(x); // (1)
    var x = 'local';
}
foo();
console.log(x); // global
```

* ***foo함수 내부에서 선언된 지역 변수*** x는
  1. (1) 시점에서 이미 선언, undefined 초기화 상태 → (1)은 값 할당 전 시점이므로 undefined 출력
  2. 변수 할당문으로 값 할당


> 호이스팅은 변수 선언이 스코프의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징을 일컬으며, 스코프 단위로 동작한다.
> * 전역 변수의 호이스팅: 전역 변수의 선언이... → 그러므로 전역 전체에서 유효
> * 지역 변수의 호이스팅: 지역 변수의 선언이...→ 그러므로 (지역)함수 전체에서 유효


### 14.1.2 전역 변수의 생명 주기

함수와 달리, 전역 코드는
1. 명시적인 호출 없이 실행: 코드가 로드되자마자 곧바로 해석되고 실행됨
   * 함수는 실행되는 특별한 진입점이 있음
2. 반환문 사용X, 마지막 문 실행된 다음(더는 실행할 문이 없을 때) 종료
   * 함수는 함수 몸체의 마지막 문 또는 반환문이 실행되면 종료됨

> **var 키워드**로 선언한 전역 변수는 전역 객체의 프로퍼티가 됨
> <br>그 말인즉슨, 전역 변수의 생명 주기 = 전역 객체의 생명 주기


> 전역 객체(global object)
> * 코드가 실행되기 이전, 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수 객체
>   * 클라이언트 사이드 환경(브라우저): window 객체
>   * 서버 사이드 환경(Node.js): global 객체
> * 환경에 따라 전역 객체를 가리키는 다양한 식별자가 존재하나, ES11에서 **globalThis**로 통일
>   * window, self, this, frames, global 등등이 존재
> * 프로퍼티로 가지는 것: 표준 빌트인 객체, 환경에 따른 호스트 객체, var 키워드로 선언한 전역 변수와 전역 함수
>   * 표준 빌트인 객체: Object, String, Number, Function, Array...
>   * 환경에 따른 호스트 객체: 클라이언트 Web API/Node.js의 호스트 API


## 14.2 전역 변수의 문제점

1. 암묵적 결합(implicit coupling) 허용
   * 말인즉슨, 모든 코드가 전역 변수를 참조하고 변경할 수 있다.
   * 변수의 유효 범위가 클수록 코드 가독성은 떨어지고 의도치 않은 상태 변경의 위험성은 커진다.
2. 긴 생명 주기
   * 그만큼 메모리 리소스도 오랜 기간 소비하고
   * 전역 변수의 상태를 (예기치 않게) 변경할 시간, 기회도 더 많다
   * 특히 var 키워드는 변수 중복 선언을 허용하므로 변수 이름 중복, 의도치 않은 재할당 가능성이 커진다.
   #### 예제 14-03
    ```Javascript
   var x = 1;
   // ... 
   var x = 100; // 변수 중복 선언, 재할당 일어남
   console.log(x); // 100 
    ```
3. 스코프 체인 상에서 종점에 존재
   * 전역 변수의 검색 속도가 가장 느리다. <br> 검색 속도의 차이는 크지 않지만 분명하다.
4. 네임스페이스 오염
   * 자바스크립트에서는 파일이 분리되어있어도 하나의 전역 스코프를 공유하는데, <br>이로 인해 다른 파일 내에서 동일한 이름으로 명명된 전역 변수/함수가 같은 스코프 내에 존재하면 예상치 못한 오류 발생 가능

## 14.3 전역 변수의 사용을 억제하는 방법

> 변수 스코프는 좁을수록 좋기에, <br> 전역 변수를 사용할 필수적인 이유가 없다면 지역 변수를 사용하는 편이 낫다.

### 14.3.1 즉시 실행 함수: 모든 코드를 즉시 실행 함수로 감싸면 모든 변수 = 즉시 실행 함수의 지역 변수가 된다.
* 전역 변수 생성을 피할 수 있어서 라이브러리 등에 자주 사용된다.
#### 예제 14-04
```Javascript
(function () {
   var foo = 10; // 즉시 실행 함수의 지역 변수 
}());
console.log(foo); // ReferenceError: foo is not defined // 전역 변수가 없다는 것을 알려주는 에러
```


### 14.3.2 네임스페이스 객체: 전역에 네임스페이스 역할 담당 객체 생성 후, <br> 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가
* 네임스페이스 분리해서 식별자 충돌 방지하는 효과 있음
* 네임스페이스 객체 자체가 전역 변수에 할당된다는 점에서는 유용성 떨어짐

#### 예제 14-05, 14-06
```Javascript
var MYAPP = {}; // 전역 네임스페이스 객체
MYAPP.name = 'Lee';
console.log(MYAPP.name); // Lee

// 이런 식으로 계층화도 가능
MYAPP.person = {
    name: 'Lee',
    address: 'Seoul'
};

console.log(MYAPP.person.name); // Lee
```

### 14.3.3 모듈 패턴

> 모듈 패턴: 클래스를 모방해서 서로 관련이 있는 변수와 함수(들)를(을) 모아 즉시 실행 함수로 감싸 하나의 모듈로 만드는 것
> * 클로저 기반으로 동작
> * 전역 변수의 억제는 물론 캡슐화까지 구현 가능
>   * 정보 은닉을 구현하기 위해 사용
>   * 자바스크립트는 접근 제한자를 제공하지 않음
> > 캡슐화(encapsulation): 프로퍼티 + 메서드 하나로 묶는 것
> 
> > 정보 은닉(information hiding): 특정 프로퍼티/메서드를 감출 목적으로 캡슐화를 이용하는 것

#### 예제 14-07: 퍼블릭 멤버(public member), 프라이빗 멤버(private member)

```Javascript
var Counter = (function () {
    var num = 0; // private 변수 역할 // private member
    
    return { // 외부로 공개할 데이터/메서드를 프로퍼티로 추가한 객체 반환용 // public member
        increase() {
            return ++num;
        },
        decrease() {
            return --num;
        }
    };
}());

console.log(Counter.num); // undefined // private 변수는 외부 노출 X

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```


### 14.3.4 ES6 모듈: ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없으며, 해당 모듈은 파일 자체의 독자적인 모듈 스코프를 제공
* 모듈 내에서 var 키워드로 선언한 변수는 더는 전역 변수가 아니며, window 객체의 프로퍼티도 아님


* 모던 브라우저에서는 ES6 모듈 사용 가능
  * 모던 브라우저 = Chrome 61, FF 60, SF 10.1, Edge 16 이상 
  * IE를 포함한 구형 브라우저에서는 동작X. 이 경우 대비해서 Webpack 등의 모듈 번들러 사용이 아직까지는 더 일반적
* script 태그에 type="module" attribute를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작
  * 모듈 파일 확장자는 mjs 권장

#### 예제 14-08
```Javascript
<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>
```
