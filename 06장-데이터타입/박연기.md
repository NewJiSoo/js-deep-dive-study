자바스크립트는 **7개의 데이터 타입을 제공**한다. 7개의 데이터 타입은 **원시 타입과 객체 타입으로 분류**할 수 있다.

<img src="https://github.com/user-attachments/assets/b158f85d-0cdd-48ca-b279-a42f06be861c" width=350> 

**숫자 타입의 값 1**과 **문자열 타입의 값 “1”**은 비슷해 보이지만 **전혀 다른 값**이다. 생성한 **목적과 용도가 다르고** 확보해야 할 **메모리 공간의 크기도 다르고** 메모리에 **저장되는 2진수도 다르며** 읽어 들여 **해석하는 방식도 다르다.**

---

# 6.1 숫자 타입

c나 자바의 경우에는 int, long, float, double 등과 같이 다양한 숫자 타입을 제공한다. 자바스크립트는 독특하게 하난의 숫자 타입만 존재한다.

ECMAScript 사양에 따르면 **숫자 타입의값은 배정밀도 64비트 부동소수점 형식**을 따른다. 즉, **모든 수를 실수로 처리**하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.

```jsx
console.log(0.2 + 0.4 === 0.6); // false
console.log(0.2 + 0.4); //0.6000000000000001
```

정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 **배정밀도 64비트 부동소수점 형식의 2진수로 저장**된다. 이들 값을 참조하면 **모두 10진수로 해석**된다.

<img src="https://github.com/user-attachments/assets/0d9d5c6b-ce4e-4df7-af9e-f75049b9607f" width=350> 

숫자 타입은 모두 실수로 처리된다고 했다. 이는 **정수로 표시해도 사실은 실수**라는 의미다. 따라서 **정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다.**

```jsx
// 숫자 타입은 모두 실수로 처리된다.
console.log(1 === 1.0) // true

console.log(4 / 2) // 2
console.log(3 / 2) // 1.5
```

숫자 타입은 추가적으로 세가지 특별한 값도 표현할 수 있다.

1. Infinity : 양의 무한대
2. -Infinity : 음의 무한대
3. NaN : 산술 연산 불가

```jsx
console.log(10 / 0) // Infinity
console.log(10 / -0) // -Infinity
console.log(1 * "string") // NaN
```

자바스크립트는 대소문자 구분을 하기 때문에 NaN을 NAN, Nan, nan으로 표현하면 에러가 발생한다.

```jsx
var x = nan // ReferenceError: nan is not defined
```

---

# 6.2 문자열 타입

**문자열**은 0개 이상의 **16비트 유니코드 문자 (UTF-16)의 집합**으로 전 세계 대부분의 문자를 표현할 수 있다. 

**문자열**은 원시타입이며 **변경 불가능한 값**이다. 이것은 문자열이 생성되면 그 **문자열을 변경할 수 없다**는 것을 의미한다.

**문자열은 작은따옴표(’’),  큰따옴표(””) 또는 백틱(``)으로 텍스트를 감싼다.** 가장 일반적인 방식은 작은따옴표를 사용하는 것이다.

```jsx
var string;
string = 'string' // 작은따옴표
string = "string" // 큰따옴표
string = `string` // 벡틱

string = '작은따옴표로 감싼 문자열 내의 "큰따옴표"는 문자열로 인식된다.'
string = "큰따옴표감싼 문자열 내의 '작은따옴표로'는 큰따옴표인식된다."
```

다른 타입과는 다르게 **따옴표로 감싸는 이유**는 **키워드나 식별자 같은 토큰과 구분하기 위해서**다. 따옴표를 사용하지 않으면 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로 인식한다.

- 토큰 : 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드

```jsx
// 따옴표를 감쌓지 않은 hello는 식별자로 인식한다.
var string = hello' // ReferenceError : hello is not defined
```

---

# 6.3 템플릿 리터럴

**ES6**부터 도입된 문자열 표기법으로, **멀티라인 문자열**, **표현식 삽입**, **태그드 템플릿** 등 편리한 문자열 처리 기능을 제공한다. 템플릿 리터럴은 **런타임에 일반 문자열로 변환되어 처리**된다.

벡틱을 사용하여 표시한다

```jsx
var template = `Template literal`
```

### 6.3.1 멀티라인 문자열

일반 문자열 내에서는 줄바꿈이 허용되지 않는다.

```jsx
var str = 'Hello
world.';
// SyntaxError : Invalid or Unexpected token
```

따라서 **일반 문자열** 내에서 **공백을 표시하려면** 백슬래시로 시작하는 **이스케이프 시퀀스를 사용해야 한다.**

<img src="https://github.com/user-attachments/assets/0f1df454-7850-4ee5-989e-78655ce47969" width=350> 

- 라인 피드와 캐리지 리턴
    - **개행 문자**는 텍스트의 **한 줄이 끝남을 표시하는 문자 또는 문자열**이다. 개행 문자로는 **라인 피드(\n) 캐리지 리턴(\r)이 존재**한다. **라인피드(\n)**은 커서를 정지한 상태에서 **종이를 한 줄 올리는 것**이고, **캐리지 리턴(\r)**은 종리를 움직이지 않고 **커서를 맨 앞줄로 이동하는 것**이다. 초창기 컴퓨터는 CRLF(\r\n)로 커서를 맨 앞으로 이동시키고 종리를 한 줄 올리는 방식으로 개행했다.
        
        현대의 컴퓨터 운영체제는 서로 다른 체계의 개행 방식을 사용한다. **자바스크립트**에서는 라인 피드와 캐리지 리턴은 모두 개행을 의미한다. 하지만 캐리지 리턴(\r)로 개행하는 경우는 거의 없고 **일반적으로 라인 피드(\n)를  사용해 개행**한다.
        

일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용된다.

<img src="https://github.com/user-attachments/assets/430f8d5b-ac75-47fd-9643-8a10cca8dd69" width=350> 

### 6.3.2 표현식 삽입

문자열은 문자열 연산자 +를 사용해 연결할 수 있다. **+ 연산자는** **피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작**한다.

```jsx
var first = "Ung-mo";
var last = "Lee";

console.log('My name is ' + first + ' ' + last + '.');
// My name is Ung-mo Lee.
```

**템플릿 리터럴**내에서는 **표현식 삽입을 통해 간단히 문자열을 삽입**할 수 있다.

```jsx
var first = "Ung-mo";
var last = "Lee";

console.log(`My name is ${first} ${last}.`);
// My name is Ung-mo Lee.
```

- 표현식을 삽입하려면 **${}으로 표현식을 감싼다.** 이때 표현식의 결과가 문자열이 아니더라도 문자열로 타입이 강제로 변환되어 삽입된다.

---

# 6.5 undefined 타입

var 키워드로 선언한 **변수는 암묵적으로 undefined로 초기화** 된다. 따라서 변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 undefined가 반환된다.

```jsx
var foo;
console.log(foo) // undefiend
```

`undefined`는 개발자가 의도적으로 할당하기 위한 값이 아니라 **자바스크립트 엔진이 변수를 초기화할 때 사용하는 값**이다. 변수를 참조했을 때 undefined가 반환된다면 해당 변수가 선언이후 할당된 적이 없는, 초기화되지 않은 변수라는 것을 간파할 수 있다.

`undefined`를 **개발자가 의도적으로 변수에 할당**한다면 undefined의 본래 취지와 어긋날뿐더러 **혼란을 줄 수 있으므로 권장하지 않는다.**

**변수에 값이 없다는 것을 명시하고 싶을 때는 어떻게 하면 좋을까?** 이런 경우에는 **null을 할당**한다.

- 선언과 정의
    - undefined를 직역하면 “정의되지 않은”이다. 자바스크립트의 **undefined에서 말하는 정의란 변수에 값을 할당하여 변수의 실체를 명확히 하는 것**을 말한다.
        
        자바스크립트는 변수를 선언하면 암묵적으로 정의가 이뤄지기 때문에 선언과 정의 구분이 모호하다.
        
        ECMAscript 사양에서 **변수는 ‘선언하다’**, **함수는 ‘정의하다**’라고 표현한다/
        

---

# 6.6 null 타입

null은 변수에 값이 없다는 것을 의도적으로 명시할 때 상용한다. null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미다. 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행할 것이다.

```jsx
var foo = "Lee"

// 이전 참조를 제거
foo = null
```

---

# 6.7 심벌 타입

ES6에 추가된 타입으로, **변경 불가능한 원시 타입의 값**이다. 심벌 값은 **다른 값과 중복되지 않는 유일무이한 값**이다. 주로 이름이 충돌할 위험이 없는 객체의 **유일한 프로퍼티 키를 만들기 위해 사용**된다.

심벌 이외의 원시타입은 리터럴을 통해 생성하지만 **심벌은 Symbol 함수를 호출해 생성**한다. 이때 생성된 심벌값은 외부에 노출되지 않으며, **다른 값과 절대 중복되지 않는 유일무이한 값**이다.

```jsx
var key = Symbol('key');
console.log(typeof key) // symbol

var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = 'vlaue';
console.log(obj[key]) // value
```

---

# 6.8 객체 타입

데이터 타입은 크게 **원시 타입**과 **객체 타입**으로 분류한다. 자바스크립트는 객체 기반의 언어이며, **자바스크립트를 이루고 있는 거의 모든 것이 객체**라는 것이다. 지금까지 살펴본 **6가지 데이터 타입 이외의 값은 모두 객체 타입**이다.

---

# 6.9 데이터 타입의 필요성

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

값은 메모리에 저장하고 참조할 수 있어야 한다. **값을 저장**하려면 먼저 확보해야 할 **메모리 공간의 크기를 결정**해야 한다. 다시 말해, 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야 한다.

```jsx
var score = 100;
```

위 코드를 실행하면 **숫자 값 100을 저장하기 위해 메모리 공간을 확보**한 다음, 확보된 **메모리에 숫자 값 100을 2진수로 저장**한다. 

**자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보**한다. 즉, 변수에 할당되는 값의 **데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정**된다. 위 예제의 경우 리터럴 100을 **숫자 타입의 값으로 해석하고 8바이트** (숫자르 64비트 부동소수점을 사용하기 때문) 메모리 **공간을 확보**한다. 그리고 **100을 2진수로 저장**한다.

<img src="https://github.com/user-attachments/assets/26619179-9a3a-4fc5-b0aa-39bf04c2b472" width=350> 

이번에는 값이 **참조하는 경우**를 생각해보자. 값을 참조하려면 **한 번에 읽어 들어야 할 메모리 공간의 크기를 알아야 한다**. score의 경우, 저장되어 있는 값이 **숫자 타입이므로 8바이트 단위로 읽어 들이지 않으면 값이 훼손**된다. 자바스크립트 엔진은 score 변수를 **숫자 타입으로 인식**한다. 따라서 score 변수를 참조하면 **8바이트 단위로 메모리 공간에 저장된 값을 읽어 들인다.**

- **심벌 테이블**
    - 컴파일러 또는 인터프리터는 심벌 테이블이라고 부르는 자료 구조를 통해 **식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리**한다.

### 6.9.2 데이터 타입에 의한 값의 해석

메모리에서 읽어 들인 **2진수를 어떻게 해석**할까?

메모리에 저장된 값은 **데이터 타입에 따라 다르게 해석**될 수 있다. 메모리에 저장된 값 **0100 0001**을 **숫자로** 해석하면 **65**지만 **문자열로** 해석하면 **A**다. 

score변수에 할당된 값은 숫자 타입의 값이다. 따라서 **score 변수를 참조하면 2진수를 숫자로 해석**한다.

지금까지 살펴본 데이터 타입의 정리

- 자바스크립트의 모든 값은 데이터 타입을 갖는다.
- 데이터 타입이 필요한 이유
    - 값을 저장할 때 확보해야 하는 **메모리 공간의 크기를 결정**하기 위해
    - 값을 참조할 때 한 번에 **읽어 들여야 할 메모리 공간의 크기를 결정**하기 위해
    - 메모리에서 읽어 들인 **2진수를 어떻게 해석할지 결정**하기 위해

---

# 6.10 동적 타이핑

### 6.10.1 동적 타입 언어와 정적 타입 언어

자바스크립트의 모든 값은 데이터 타입을 가진다고 했다. 그러면 **변수는 데이터 타입을 가질까?**

**C나 자바 같은 정적 타입 언어**는 변수 선언시 **데이터 타입을 사전에 선언**해야 한다. 이를 **명시적 타입 선언**이라 한다.

정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다.

**자바스크립트는** 정적 타입 언어와 다르게 변수를 선언할 때 **타입을 선언하지 않는다.** 자바스크립트의 변수는 **어떠한 데이터 타입의 값이라도 자유롭게 할당**할 수 있다.

```jsx
var foo;
console.log(typeof foo); // undefined

foo = 3;
console.log(typeof foo); // number

foo = "hello";
console.log(typeof foo); // string
 
foo = true;
console.log(typeof foo); // boolean

foo = null;
console.log(typeof foo); // object

foo = Symbol();
console.log(typeof foo); // symbol

foo = {}
console.log(typeof foo); // object

foo =[]
console.log(typeof foo); // object

foo = funciton(){}
console.log(typeof foo); // function
```

자바스크립트에서는 **값을 할당하는 시점에 변수의 타입이 동적으로 결정**되고 **변수의 타입을 언제든지 자유롭게 변경**할 수 있다. 

**자바스크립트의 변수는** 선언이 아닌 **할당에 의해 타입이 결정**된다. 그리고 **재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.** 이러한 특징을 **동적 타이핑**이라 하고 정적 타입 언어와 구별하기 위해 **동적 타입 언어**라 한다.

그러면 **변수는 타입을 가질까?** 기본적으로 변수는 타입을 가지지 않는다. 값은 타입을 갖는다. 변수의 타입의 **현재 할당되어 있는 값에 의해 동적으로 결정**된다고 표현하는 것이 적절하다.

### 6.10.2 동적 타입 언어와 변수

**동적 타입 언어**의 구조적인 **단점**

1. 복잡한 프로그램에서 변화하는 **변수 값을 추적하기 어려울 수 있다.**
    - 값의 변경에 의해 타입도 언제든지 변경될 수 있다.
    - 동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다.
2. **개발자의 의도와는 상관없이** 자바스크립트 엔진에 의해 암묵적으로 **타입이 자동으로 변환**된다.

이러한 점을 통해 **동적 타입 언어**는 **유연성은 높지만 신뢰성은 떨어진다.**

변수를 사용할 때 **주의 사항**

1. **변수**는 꼭 필요한 경우에 한해 **제한적으로 사용**
    1. 변수의 갯수가 많으면 많을수록 오류가 발생할 확률도 높아진다.
    2. 변수의 무분별한 남발은 금물이며, 필요한 만큼 최소한으로 유지해야 한다.
2. **유효 범위(scope)는 최대한 좁게 만들기**
    1. 변수의 유효 범위가 넓으면 넓을수록 변수로 인해 오류가 발생할 확률이 높아진다.
3. **전역 변수는 최대한 사용하지 않기**
    1. 의도치 않게 값이 변경될 가능성이 높고 다른 코드에 영향을 줄 가능성이 높다.
    2. 프로그램의 복잡성을 증가시키고 처리 흐름을 추적하기 어렵게 만듬
4. 변수보다 **상수를 사용해 값의 변경을 억제**하기
5. **변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍**한다.
    1. 개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만든다.

> [!note]
>💡 가독성이 좋은 코드가 좋은 코드다



> 컴퓨터가 이해하는 코드는 어떤 바보도 쓸 수 있다. 하지만 훌륭한 프로그래머는 사람이 이해할 수 있는 코드르 쓴다.
>
> 마틴 팔울러
