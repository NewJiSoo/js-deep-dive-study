# 25. 클래스
## 25.1 클래스는 프로토타입의 문법적 설탕인가?

#### 결론부터 말하자면 단순 설탕X ***새로운 객체 메커니즘O***
* 클래스는 ES6에서 도입: 즉, ES6는 새로운 객체 생성 메커니즘을 소개해준 것?!

#### 클래스는 생성자 함수와 달리
1. new 연산자 없이 호출하면 에러가 발생한다
2. 상속을 지원하는 extends와 super 키워드를 제공한다.
3. 호이스팅이 발생하지 않는 것처럼 동작한다.
4. 모든 코드에는 암묵적으로 strict mode가 지정된 채로 실행되며 이는 해제 불가능하다
5. constructur, prototype method, static method 모두 property attribute [[Enumerable]] value가 false다. (열거되지 않는다)


#### 예제 25-01: Javascript(ES5) - 클래스 없이도 OOP 상속 구현 가능
```Javascript
// ES5 생성자 함수
var Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }

  // 프로토타입 메서드
  Person.prototype.sayHi = function () {
    console.log('Hi! My name is ' + this.name);
  };

  // 생성자 함수 반환
  return Person;
}());

// 인스턴스 생성
var me = new Person('Lee');
me.sayHi(); // Hi! My name is Lee
```

<br>

## 25.2 클래스 정의

#### `class` 키워드를 사용하여 정의함
#### 클래스 이름은 생성자 함수와 마찬가지로 Pascal case(대문자로 시작)를 사용하는 것이 일반적<br>안 써도 에러가 발생하지는 않지만 어색해보임


#### 예제 25-02: 클래스 선언문
```Javascript
class Person {}
```

<br>

#### 클래스는 일급 객체!
1. 무명 리터럴 생성 가능(런타임에 생성 가능)
2. 변수/자료구조(객체 배열 등)에 저장 가능
3. 함수 매개변수에 전달 가능
4. 함수 반환값으로 사용 가능

#### 클래스는 함수이기도 하다. 따라서 클래스는 값처럼 사용 가능한 일급 객체~

<br>

#### 클래스 몸체에는 0개 이상의 메서드만 생성 가능
* 클래스 몸체에서 정의 가능한 메서드
1. 생성자(constructor)
2. prototype method
3. static method

#### 예제 25-04
```Javascript
// 클래스 선언문
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 public하다.
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }

  // 정적 메서드
  static sayHello() {
    console.log('Hello!');
  }
}

// 인스턴스 생성
const me = new Person('Lee');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee
// 정적 메서드 호출
Person.sayHello(); // Hello!
```

#### 그림 25-1: 클래스 정의 방식 vs 생성자 함수 정의 방식: 둘은 형태 면에서 매우 유사
![img.png](shi_images%2Fimg.png)

<br>

## 25.3 클래스 호이스팅

#### 예제 25-05: 클래스는 함수로 평가된다.
```Javascript
// 클래스 선언문
class Person {}

console.log(typeof Person); // function
```

#### 프로토타입과 생성자 함수는 단독으로 존재할 수 없다. 언제나 쌍(pair)을 이루는 이유
* 클래스 선언문으로 정의한 클래스는 함수 선언문처럼 런타임 이전에 먼저 평가된 후 함수 객체 생성
  * 이때 생성된 함수 객체는 생성자 함수로서 호출 가능한 함수(constructor)
    * 함수 객체를 생성하는 시점에 prototype도 더불어 생성

<br>

#### 예제 25-06: 클래스는 클래스 정의 이전에 참조 불가
```Javascript
console.log(Person);
// ReferenceError: Cannot access 'Person' before initialization

// 클래스 선언문
class Person {}
```

<br>

#### 예제 25-07: 클래스 선언문은 호이스팅이 발생하지 않는 듯하면서도 발생한다
```Javascript
const Person = '';

{
  // 호이스팅이 발생하지 않는다면 ''이 출력되어야 한다.
  console.log(Person);
  // ReferenceError: Cannot access 'Person' before initialization

  // 클래스 선언문
  class Person {}
}
```

* 클래스는 `let`, `const` 키워드 선언 변수처럼 호이스팅됨
* 호이스팅이 발생하지 않는 것처럼 동작하는 이유? 클래스 선언문 이전에 TDZ에 빠지기 때문

> 모든 선언문은 런타임 이전에 먼저 실행되기 때문에, <br> `var`, `let`, `const`, `function`, `class` 키워드로 선언된 모든 식별자는 호이스팅된다.

<br>

## 25.4 인스턴스 생성

#### 예제 25-08: 클래스는 생성자 함수이며, `new` 연산자와 함께 호출되어 인스턴스를 생성한다.
```Javascript
class Person {}

// 인스턴스 생성
const me = new Person();
console.log(me); // Person {}
```

<br>

#### 예제 25-09: 클래스는 인스턴스 생성이 유일한 존재 이유이므로(?) 반드시 `new` 연산자와 함께 호출 필수!
```Javascript
class Person {}

// 클래스를 new 연산자 없이 호출하면 타입 에러가 발생한다.
const me = Person();
// TypeError: Class constructor Person cannot be invoked without 'new'
```

<br>

#### 예제 25-10: 클래스 표현식으로 정의된 클래스 -> 클래스 식별자 대신 기명클래스 표현식의 클래스 이름(MyClass)로 인스턴스를 생성하면 에러 발생
```Javascript
const Person = class MyClass {};

// 함수 표현식과 마찬가지로 클래스를 가리키는 식별자로 인스턴스를 생성해야 한다.
const me = new Person();

// 클래스 이름 MyClass는 함수와 동일하게 클래스 몸체 내부에서만 유효한 식별자다.
console.log(MyClass); // ReferenceError: MyClass is not defined

const you = new MyClass(); // ReferenceError: MyClass is not defined
```

* (기명 함수 표현식과 마찬가지로,) 클래스 표현식에서 사용한 클래스 이름은 외부 코드에서 접근 불가능

<br>


## 25.5 메서드

> 클래스 정의에 대한 새로운 제안 사양:
> <br>ES11/ESMAScript2020 -> 인스턴스 프로퍼티는 반드시 constructor 프로퍼티 내부에서 정의해야 함
> <br>2021.1 -> 클래스 몸체에 프로퍼티를 직접 정의할 수 있는 새로운 표준 사양 제안된 상태

#### 클래스 몸체에 정의 가능한 메서드(0개 이상의 메서드만 선언 가능)
1. constructor
2. prototype method
3. static method

<br>

### 25.5.1 constructor

#### 예제 25-11: constructor는 인스턴스 생성&초기화 전용 특수 메서드이며, 이름 변경 불가
```Javascript
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }
}
```

#### 예제 25-12: 클래스 내부 -> 크롬 브라우저 개발자 도구에서 살펴보기
```Javascript
// 클래스는 함수다.
console.log(typeof Person); // function
console.dir(Person);
```

#### 그림 25-2: 클래스는 함수다
![img_1.png](shi_images%2Fimg_1.png)

* 여기서 보다시피 클래스는 평가되어 함수 객체가 됨
* 클래스도 함수 객체 고유의 프로퍼티를 모두 가지고 있음!
  * 또한 프로토타입하고도 연결되어있고
  * 자신의 스코프 체인도 구성하고 있고

* prototype property -> prototype 객체 -> constructor property -> 클래스 자신
  * 클래스가 인스턴스를 생성하는 생성자 함수라는 뜻
  * new 연산자와 함께 클래스 호출 -> 클래스는 인스턴스를 생성

<br>

#### 예제 25-13: 크롬 브라우저 2탄(클래스가 생성한 인스턴스 내부를 보자)
```Javascript
// 인스턴스 생성
const me = new Person('Lee');
console.log(me);
```

#### 그림 25-3 Person 클래스로 생성한 인스턴스
![img_2.png](shi_images%2Fimg_2.png)

* Person class constructor 내부: this에 추가한 name 프로퍼티 -> 클래스가 생성한 인스턴스의 프로퍼티로 추가가 됐네?
* (생성자 함수와 마찬가지로) constructor 내부에서 this에 추가한 property는 instance property가 된다
* constructor 내부 this -> 클래스가 생성한 instance를 가리킴

#### 예제 25-14
```Javascript
// 클래스
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }
}

// 생성자 함수
function Person(name) {
  // 인스턴스 생성 및 초기화
  this.name = name;
}
```

<br>

* 재밌는 점? 클래스가 평가되어 생성돤 함수 객체/클래스가 생성한 인스턴스 어디에도 constructor 메서드가 보이지 않음
  * 클래스 몸체에 정의한 constructor는 단순한 메서드가 아니다<br>메서드로 해석X, 클래스가 평가되어 생성한 함수 객체 코드의 일부가 됨
  * 그 말인즉슨 -> 클래스 정의가 평가되면 constructor에 기술된 동작을 하는 함수 객체가 생성된다는 뜻 

> 클래스의 constructor 메서드, prototype의 constructor property
> * 직접적인 관련 없음
> * prototype constructor property -> 모든 프로토타입이 지닌 프로퍼티이자 생성자 함수를 가리킴

<br>

#### 예제 25-15: constructor가 생성자 함수와 유사해도 구별되는 점: (1) 클래스 내에 최대 한 개 (2) 클래스가 2개 이상의 constructor 포함하면 문법 에러 발생(SyntaxError)
```Javascript
class Person {
  constructor() {}
  constructor() {}
}
// SyntaxError: A class may only have one constructor
```

<br>

#### 예제 25-16: constructor는 생략 가능
```Javascript
class Person {}
```

<br>

#### 예제 25-17: constructor 생략시 빈 constructor 암묵적으로 정의됨 & constructor 생략 클래스는 빈 constructor에 의해 빈 객체를 생성함
```Javascript
class Person {
  // constructor를 생략하면 다음과 같이 빈 constructor가 암묵적으로 정의된다.
  constructor() {}
}

// 빈 객체가 생성된다.
const me = new Person();
console.log(me); // Person {}
```

<br>

#### 예제 25-18: 프로퍼티가 추가되어 초기화된 인스턴스를 생성하려면, constructor 내부에서 this에 인스턴스 프로퍼티 추가
```Javascript
class Person {
  constructor() {
    // 고정값으로 인스턴스 초기화
    this.name = 'Lee';
    this.address = 'Seoul';
  }
}

// 인스턴스 프로퍼티가 추가된다.
const me = new Person();
console.log(me); // Person {name: "Lee", address: "Seoul"}
```

<br>

#### 예제 25-19: 클래스 외부 -> 인스턴스 프로퍼티 초기값 전달: constructor에 매개변수 선언 & 인스턴스 생성시 초기값 전달<br>(초기값은 constructor의 매개변수에 전달됨)
```Javascript
class Person {
  constructor(name, address) {
    // 인수로 인스턴스 초기화
    this.name = name;
    this.address = address;
  }
}

// 인수로 초기값을 전달한다. 초기값은 constructor에 전달된다.
const me = new Person('Lee', 'Seoul');
console.log(me); // Person {name: "Lee", address: "Seoul"}
```

* constructor 내에서는 인스턴스 생성과 동시에 인스턴스 프로퍼티 추가를 통해 인스턴스 초기화를 실행함
  * 그러므로 인스턴스를 초기화하려면 constructor 생략 불가
* constructor는 별도의 반환문을 갖지 않아야 함: new 연산자와 함께 클래스가 호출되면 생성자 함수와 동일하게 암묵적으로 this(인스턴스)를 반환하기 때문
  * this가 아닌 다른 객체를 명시적으로 반환하면? -> this(인스턴스)가 반환되지 못하고 return문에 명시한 객체가 반환됨

#### 예제 25-20
```Javascript
class Person {
  constructor(name) {
    this.name = name;

    // 명시적으로 객체를 반환하면 암묵적인 this 반환이 무시된다.
    return {};
  }
}

// constructor에서 명시적으로 반환한 빈 객체가 반환된다.
const me = new Person('Lee');
console.log(me); // {}
```

<br>

### 25.5.2 프로토타입 메서드

#### 예제 25-22: 생성자 함수를 사용하여 인스턴스를 생성할 때, 프로토타입 메서드를 생성하기 위해서는? <br>명시적으로 프로토타입에 메서드를 추가해야 한다.
```Javascript
function Person(name) { // 생성자 함수
    this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHi = function() {
    console.log(`Hi! My name is ${this.name}`);
};

const me = new Person('Lee');
me.sayHi(); // Hi! My name is Lee
```

<br>

#### 예제 25-23: 클래스 몸체에서 정의한 메서드 -> 별도로 메서드 추가하지 않아도 기본적으로 프로토타입 메서드가 된다
```Javascript
class Person {
    // 생성자
    constructor(name) {
        this.name = name; // 인스턴스 생성 및 초기화
    }
    
    sayHi() { // 프로토타입 메서드
        console.log(`Hi! My name is ${this.name}`);
    }
}

const me = new Person('Lee');
me.sayHi(); // Hi! My name is Lee
```

<br>

#### 예제 25-24: 생성자 함수처럼, 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 됨
```Javascript
Object.getPrototypeOf(me) === Person.prototype;
me instanceof Person; // true

Object.getPrototypeOf(Person.prototype) === Object.prototype;
me instanceof Object; // true

me.constructor === Person; // true
```
1. me 객체의 프로토타입은 Person.prototype 이다
2. Personn.prototype의 프로토타입은 Object.prototype이다
3. me 객체의 constructor는 Person 클래스다.

<br>

#### 그림 25-24: 클래스로 생성한 인스턴스의 프로토타입 체인
![img_3.png](shi_images%2Fimg_3.png)

1. 클래스 몸체에서 정의한 메서드는 인스턴스 프로토타입에 존재하는 프로토타입 메서드가 된다
2. 인스턴스는 프로토타입 메서드를 상속받아 사용 가능하다
3. 프로토타입 체인은 기존의 모든 객체 생성 방식뿐만 아니라 클래스에 생성된 인스턴스에도 동일하게 적용된다. <br> 생성자 함수의 역할을 클래스가 할 뿐이다.
   * 객체 생성 방식: 객체 리터럴, 생성자 함수, Object.create 메서드 등
4. 클래스는 생성자 함수처럼 인스턴스를 생성하는 생성자 함수라고 볼 수 있다.<br> = 클래스는 생성자 함수처럼 *프로토타입 기반 객체 생성 메커니즘*이다.

<br>

### 25.5.3 정적(static) 메서드
#### 인스턴스를 생성하지 않아도 호출할 수 있는 메서드

#### 예제 25-25: 생성자 함수의 경우, 정적 메서드를 생성하기 위해서는 생성자 함수에 메서드를 명시적으로 추가해야 한다.
```Javascript
function Person(name) { // 임의의 생성자 함수
    this.name = name;
}

Person.sayHi = function() { // 임의의 정적 메서드
    console.log('Hi!');
};

// 인스턴스 없이 호출 가능 // 정적 메서드 호출
Person.sayHi(); // Hi!
```

<br>

#### 예제 25-26: 클래스의 경우, 메서드에 `static` 키워드를 붙이면 정적 메서드(클래스 메서드)가 됨
```Javascript
class Person {
    constructor(name) { // 생성자
        this.name = name; // 인스턴스 생성 및 초기화
    }
    
    static sayHi() { // static // 정적 메서드
        console.log('Hi!');
    }
}
```

#### 그림 25-5: 예제 25-26에서 나온 정적 메서드 설명<br>위 예제의 Person 클래스는 다음과 같은 프로토타입 체인을 생성
![img_4.png](shi_images%2Fimg_4.png)
1. 정적 메서드는 클래스에 바인딩된 메서드가 됨
2. 클래스는 함수 객체로 평가되므로 자신의 프로퍼티/메서드 소유 가능
3. 클래스는 클래스 정의가 평가되는 시점에 함수 객체가 되므로 (인스턴스와 달리) 별다른 생성 과정 필요 없음
   * 따라서 정적 메서드는 클래스 정의 이후 인스턴스 생성하지 않아도 호출 가능 

<br>

#### 예제 25-27: 정적 메서드는 프로토타입 메서드처럼 인스턴스로 호출하지 않고 클래스로 호출함
```Javascript
Person.sayHi(); // Hi!
```

<br>

#### 예제 25-28: 정적 메서드는 인스턴스로 호출할 수 없다.
1. 정적 메서드가 바인딩된 클래스는 인스턴스의 프로토타입 체인상에 존재하지 않음
2. 그러므로 인스턴스로 클래스의 메서드를 상속받을 수 없음
```Javascript
const me = new Person('Lee');
me.sayHi(); // TypeError: me.sayHi is not a function
```

<br>

### 25.5.4 정적 메서드와 프로토타입 메서드의 차이

1. 속해있는 프로토타입 체인이 다르다
2. 호출 방법이 다르다
   * 정적 메서드: 클래스
   * 프로토타입 메서드: 인스턴스
3. 인스턴스 프로퍼티 참조 가능 여부(2번과 연계)
   * 정적 메서드: 불가능
   * 프로토타입 메서드: 가능

#### 예제 25-29
```Javascript
class Square {
    static area(width, height) { // static -> 정적 메서드
        return width * height;
    }
}

console.log(Square.area(10, 10)); // 100 
```
* 위의 area는 정적 메서드라 인스턴스 프로퍼티를 참조하지 않음

<br>

#### 예제 25-30
```Javascript
class Square {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }
    
    area() { // prototype method
        return this.width * this.height;
    }
}

const square = new Square(10, 10); // 인스턴스 생성
console.log(square.area()); // 인스턴스를 통해 prototype method 호출 // 100
```
* 메서드 내부에서 인스턴스 프로퍼티를 참조해야 한다면 `this`를 사용해야 한다.
  * 이 경우 프로토타입 메서드로 정의해야 한다
* 반대로 메서드 내부에서 인스턴스 프로퍼티 참조할 필요가 없다면? `this`를 사용하지 않게 된다

<br>

#### 예제 25-31: 표준 빌트인 객첻 -> 다양한 정적 메서드를 지니고 있음
* 애플리케이션 전역에서 사용 가능한 ***유틸리티utility 함수***
* 표준 빌트인 객체 예시: `Math`, `Number`, `JSON`, `Object`, `Reflect`  등
* 정적 메서드는 유틸리티 함수를 전역 함수 대신 메서드로 구조화할 때 유용
```Javascript
// 클래스/생성자 함수를 하나의 namespace로 사용하여 정적 메서드 모아놓기
// 이름 충돌 가능성 줄여줌 & 관련 함수 구조화 효과
Math.max(1, 2, 3); // 3
Number.isNaN(NaN); // true
JSON.stringify({a: 1}); // "{"a": 1}"
Object.is({},{}); // false
Reflect.has({a: 1}, 'a'); // true
```

> ES6추가: 표준 빌트인 객체 Number의 static method
> `isFinite`, `isNaN`, `parseFloat`, `parseInt`: 이 아이들은 빌트인 전역 함수인데 ES6에서 얘네들을 빌트인 객체 Number의 정적 메서드로 추가 구현함
> * Number의 정적 메서드가 빌트인 전역 함수였을 때보다 더 엄격하다

<br>

### 25.5.5 클래스에서 정의한 메서드의 특징

1. `function` 키워드를 생략한 메서드 축약 표현을 사용한다.
2. 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없다.
3. 암묵적으로 strict mode로 실행된다.
4. for ... in 문이나 Object.keys 메서드 등으로 열거할 수 없다.<br>즉 프로퍼티의 열거 가능 여부를 나타내며, boolean 값을 갖는 property attribute [[Enumerable]] 값이 false다.
5. 내부 메서드 [[Constructor]]랄 갖지 않는 `non-constructor`다. 따라서 `new` 연산자와 함께 호출 불가

<br>

## 25.6 클래스의 인스턴스 생성 과정

1. 인스턴스 생성과 this 바인딩
2. 인스턴스 초기화
3. 인스턴스 반환

#### 예제 25-32
```Javascript
class Person {
    constructor(name) {
        console.log(this); // 암묵적으로 인스턴스 생성 & this에 바인딩 // Person {}
        console.log(Object.getPrototypeOf(this) === Person.prototype); // true
        this.name = name; // this에 바인딩된 인스턴스를 초기화한다.
      
       // 완성한 인스턴스가 바인딩된 this가 암묵적으로 반환됨
    }
    
}

```

<br>

## 25.7 프로퍼티
### 25.7.1 인스턴스 프로퍼티: constructor 내부에서 정의해야 함

#### 예제 25-33
```Javascript
class Person {
  constructor(name) {
    // 인스턴스 프로퍼티
    this.name = name; // constructor 내부 코드 실행되기 이전에 이쪽 내부 this에 이미 암묵적으로 클래스가 생성한 빈 객체 인스턴스가 바인딩된 상태
  }
}

const me = new Person('Lee');
console.log(me); // Person {name: "Lee"}
```

#### 예제 25-34: 암묵적 빈 객체인 인스턴스에 프로퍼티 추가 -> 인스턴스 초기화
```Javascript
class Person { // javascript엔 접근 제한자가 없어서 언제나 public(private은 개발 중? 이미 개발됨?)
  constructor(name) {
    // 인스턴스 프로퍼티
    this.name = name; // name 프로퍼티는 public하다.
  }
}

const me = new Person('Lee');

// name은 public하다.
console.log(me.name); // Lee
```

<br>

### 25.7.2 접근자 프로퍼티(accessor property): 자체적으로 값[[value]], 내부 슬롯을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 ***접근자 함수accessor function***로 구성된 프로퍼티

#### 예제 25-35
```Javascript
const person = {
  // 데이터 프로퍼티
  firstName: 'Ungmo',
  lastName: 'Lee',

  // fullName은 접근자 함수로 구성된 접근자 프로퍼티다.
  // getter 함수
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  // setter 함수
  set fullName(name) {
    // 배열 디스트럭처링 할당: "36.1. 배열 디스트럭처링 할당" 참고
    [this.firstName, this.lastName] = name.split(' ');
  }
};

// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.
console.log(`${person.firstName} ${person.lastName}`); // Ungmo Lee

// 접근자 프로퍼티를 통한 프로퍼티 값의 저장
// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.
person.fullName = 'Heegun Lee';
console.log(person); // {firstName: "Heegun", lastName: "Lee"}

// 접근자 프로퍼티를 통한 프로퍼티 값의 참조
// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.
console.log(person.fullName); // Heegun Lee

// fullName은 접근자 프로퍼티다.
// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.
console.log(Object.getOwnPropertyDescriptor(person, 'fullName'));
// {get: ƒ, set: ƒ, enumerable: true, configurable: true}
```

<br>

#### 예제 25-36: 접근자 프로퍼티는 클래스에서도 사용 가능 -> 위 예제의 객체 리터럴을 클래스로 표현해보자
```Javascript
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  // fullName은 접근자 함수로 구성된 접근자 프로퍼티다.
  // getter 함수
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  // setter 함수
  set fullName(name) {
    [this.firstName, this.lastName] = name.split(' ');
  }
}

const me = new Person('Ungmo', 'Lee');

// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.
console.log(`${me.firstName} ${me.lastName}`); // Ungmo Lee

// 접근자 프로퍼티를 통한 프로퍼티 값의 저장
// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.
me.fullName = 'Heegun Lee';
console.log(me); // {firstName: "Heegun", lastName: "Lee"}

// 접근자 프로퍼티를 통한 프로퍼티 값의 참조
// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.
console.log(me.fullName); // Heegun Lee

// fullName은 접근자 프로퍼티다.
// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.
console.log(Object.getOwnPropertyDescriptor(Person.prototype, 'fullName'));
// {get: ƒ, set: ƒ, enumerable: false, configurable: true}
```
* getter and setter

<br>

#### 예제 25-37: 클래스 메서드는 기본적으로 프로토타입 메서드가 되며, 클래스의 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 됨
```Javascript
// Object.getOwnPropertyNames는 비열거형(non-enumerable)을 포함한 모든 프로퍼티의 이름을 반환한다.(상속 제외)
Object.getOwnPropertyNames(me); // -> ["firstName", "lastName"]
Object.getOwnPropertyNames(Object.getPrototypeOf(me)); // -> ["constructor", "fullName"]
```

#### 그림 25-6: 클래스의 접근자 프로퍼티는 프로토타입 프로퍼티다
![img_5.png](shi_images%2Fimg_5.png)

<br>

### 25.7.3 클래스 필드 정의 제안

> ***클래스 필드(class field)***
> ***
> 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어

<br>

#### 예제 25-38: 자바의 클래스 필드는 마치 클래스 내부에서 변수처럼 사용됨
```Java
public class Person { // java의 클래스 정의
    private String firstName = ""; // 클래스 필드 정의 // 클래스 몸체에 this없이 선언해야 한다
    private String lastName = "";

  // 생성자
  Person(String firstName, String lastName) {
    // ③ this는 언제나 클래스가 생성할 인스턴스를 가리킨다.
    this.firstName = firstName;
    this.lastName = lastName;
  }

  public String getFullName() {
    // ② 클래스 필드 참조
    // this 없이도 클래스 필드를 참조할 수 있다.
    return firstName + " " + lastName;
  }
}
```

<br>

#### 예제 25-39: 자바스크립트의 클래스 몸체(class body)에는 메서드만 선언 가능(자바와 유사하게 클래스 몸체에 선언할 시 문법 에러가 발생)
```Javascript
class Person {
    name = 'Lee'; // 클래스 필드 정의
}

const me = new Person('Lee');
```
* 버전에 따라(12이상) 오류(TypeError)가 안 날 수도 있음

<br>

> Technical Committee 39(TC39)
> ***
> ECMA-262(ECMAScript) 관리를 담당하는 기술 위원회
> <br> ECMA-262 사양을 제대로 준수해야 하는 기업으로 구성
> <br> 쟁쟁한 기업들 -> 구글, 애플, 마이크로소프트, 모질라 등 브라우저 벤더 & 페이스북, 트위터...


> TC39 프로세스
> ***
> ECMA-262사양(ECMAScript)에 새로운 표준 사양(제안proposal)을 추가하기 위해 공식적으로 명문화한 과정
> * 0 ~ 4단계까지 총 5단계로 구성
>   * 0 strawman -> 1 proposal -> 2 draft -> 3 candidate -> 4 finished
>     * candidate까지 승급한 제안은 심각한 문제가 없는 이상 대부분 finished까지 승급하는 편
>     * finished까지 승급한 제안은 마찬가지로 큰 이변이 없는 이상 차기 ECMAScript 버전에 포함됨
> * 상위 단계로 승급하기 위한 명시적인 조건 있음
>   * 승급 조건 충족한 제안 -> TC39 동의 -> 다음 단계로 승급
> * 현재 TC39 프로세스에 올라온 제안을 확인하려면 `ECMAScript proposals`를 확인하면 OK

<br>

#### 예제 25-40: 최신 브라우저, 최신 Node.js에서는 다음 예제와 같이 클래스 필드 클래스 몸체에 정의 가능
```Javascript
class Person {
  // 클래스 필드 정의
  name = 'Lee';
}

const me = new Person();
console.log(me); // Person {name: "Lee"}
```

<br>

#### 예제 25-41: 클래스 몸체에서 클래스 필드를 정의하는 경우 this에 클래스 필드를 바인딩해서는 안됨<br>this는 클래스의 constructor와 메서드 내에서만 유효
```Javascript
class Person {
    // this에 클래스 필드 바인딩하는 것 금지
    this.name = ''; // SyntaxError: Unexpected token '.'
}
```

<br>

#### 예제 25-42: 클래스 필드를 참조하는 경우 자바스크립트에서는 this를 반드시 사용해야 한다<br><small>(자바 등 클래스 기반 객체지향 언어는 this를 생략할 수 있다)</small>
```Javascript
class Person {
  // 클래스 필드
  name = 'Lee';

  constructor() {
    console.log(name); // ReferenceError: name is not defined
  }
}

new Person();
```

<br>


#### 예제 25-43: 클래스 필드에 초기값 미할당시 undefined value 가지게 됨

```Javascript
class Person {
  // 클래스 필드를 초기화하지 않으면 undefined를 갖는다.
  name;
}

const me = new Person();
console.log(me); // Person {name: undefined}
```

<br>

#### 예제 25-44: 인스턴스 생성시 외부의 초기값으로 클래스 필드 초기화할 필요가 있다면?<br>*constructor에서 클래스 필드 초기화 필수*

```Javascript
class Person {
  name;

  constructor(name) {
    // 클래스 필드 초기화.
    this.name = name;
  }
}

const me = new Person('Lee');
console.log(me); // Person {name: "Lee"}
```

<br>

#### 예제 25-45: 인스턴스 생성시 클래스 필드 초기화할 필요가 있다면?<br>constructor 밖에서 클래스 필드 정의할 필요 *없음*

```Javascript
class Person {
  constructor(name) {
    this.name = name;
  }
}

const me = new Person('Lee');
console.log(me); // Person {name: "Lee"}
```
1. 클래스 필드를 초기화할 필요가 있다면 어차피 constructor 내부에서 클래스 필드를 참조하여 초기값을 할당해야 하는데,
2. 이때 this(즉 클래스가 생성한 인스턴스)에 클래스 필드에 해당하는 프로퍼티가 없다면 *자동 추가*되기 때문
   1. 위의 Person class에서 name이라는 프로퍼티를 선언하지 않았어도 constructor 에서 이 클래스의 name 프로퍼티는 인자 name 값을 가진다고 선언 -> name을 밖에 선언하지 않았어도 이때 코드를 기반으로 인스턴스 생성시 해당 name 프로퍼티가 *자동 추가*된다는 뜻


<br>

#### 예제 25-46: 함수는 일급 객체이므로 함수를 클래스 필드에 할당할 수 있다.<br>그러므로, *클래스 필드를 통해 메서드를 정의할 수도 있다.*

```Javascript
class Person {
  // 클래스 필드에 문자열을 할당
  name = 'Lee';

  // 클래스 필드에 함수를 할당
  getName = function () {
    return this.name;
  }
  // 화살표 함수로 정의할 수도 있다.
  // getName = () => this.name;
}

const me = new Person();
console.log(me); // Person {name: "Lee", getName: ƒ}
console.log(me.getName()); // Lee
```

<br>

* 클래스 필드에 함수를 할당하는 경우 이 함수는 **인스턴스 메서드**가 된다(프로토타입 메서드X)
  * 모든 클래스 함수는 인스턴스 프로퍼티가 되기 때문이다
* <span style="color: red;">***따라서 클래스 필드에 함수를 할당하는 것은 권장X***</span> 


<br>

#### 예제 25-47: 클래스 필드와 화살표 함수: 화살표 함수 내부 this가 인스턴스 가리키게 하기<br><small>(인스턴스가 여러 개 생성된다면 이 방법도 메모리 손해를 감수할 수밖에 없다)</small>

```html
<!DOCTYPE html>
<html>
<body>
  <button class="btn">0</button>
  <script>
    class App {
      constructor() {
        this.$button = document.querySelector('.btn');
        this.count = 0;

        // increase 메서드를 이벤트 핸들러로 등록
        // 이벤트 핸들러 increase 내부의 this는 DOM 요소(this.$button)를 가리킨다.
        // 하지만 increase는 화살표 함수로 정의되어 있으므로
        // increase 내부의 this는 인스턴스를 가리킨다.
        this.$button.onclick = this.increase;

        // 만약 increase가 화살표 함수가 아니라면 bind 메서드를 사용해야 한다.
        // $button.onclick = this.increase.bind(this);
      }

      // 인스턴스 메서드
      // 화살표 함수 내부의 this는 언제나 상위 컨텍스트의 this를 가리킨다.
      increase = () => this.$button.textContent = ++this.count;
    }
    new App();
  </script>
</body>
</html>
```

<br>

### 25.7.4 private 필드 정의 제안

* Javascript는 캡슐화 지원이 완전하지 않음
* ES6에서도 접근 제한자 지원X -> 인스턴스 프로퍼티는 언제나 public = 언제나 클래스 외부에서 참조 가능(by 인스턴스)

<br>

#### 예제 25-48: public instsance property

```javascript
class Person {
  constructor(name) {
    this.name = name; // 인스턴스 프로퍼티는 기본적으로 public하다.
  }
}

// 인스턴스 생성
const me = new Person('Lee');
console.log(me.name); // Lee
```

<br>

#### 예제 25-49: class field 정의 제안을 하더라도 public by default

```javascript
class Person {
  name = 'Lee'; // 클래스 필드도 기본적으로 public하다.
}

// 인스턴스 생성
const me = new Person();
console.log(me.name); // Lee
```

<br>

#### 예제 25-50: 2021.1 기준 candidate -> private field 정의 새로운 표준 사양 제안<br>private field 선두에는 # 붙여주기<br>'최신' 브라우저, '최신' Node.js(12이상)에 구현된 상태

```javascript
class Person {
  // private 필드 정의
  #name = '';

  constructor(name) {
    // private 필드 참조
    this.#name = name;
  }
}

const me = new Person('Lee');

// private 필드 #name은 클래스 외부에서 참조할 수 없다.
console.log(me.#name);
// SyntaxError: Private field '#name' must be declared in an enclosing class
```

<br>

> ***타입스크립트(TypeScript)***
> ***
> * 자바스크립트의 상위 확장(superset)
> * C# 창시자 SW 엔지니어 아네르스 하일스베르(Anders Hejisberg)가 개발 주도
>   * 덴마크 출신
> * 클래스 기반 객체지향 언어 지원 접근 제한자 모두 지원 & 의미도 통함
>   * `public`, `private`, `protected`

<br>

#### 접근 제한자 개념 간략 설명(public vs private)

| 접근 가능성          | public | private |
|:----------------|:------:|:-------:|
| 클래스 내부          |   O    |    O    |
| 자식 클래스 내부       |   O    |    X    |
| 클래스 인스턴스를 통한 접근 |   O    |    X    |

<br>

#### 예제 25-51: 개념상 private field라면 클래스 외부에서 접근X, 접근자 프로퍼티를 통해 간접적으로 접근하는 건 OK

```javascript
class Person {
  // private 필드 정의
  #name = '';

  constructor(name) {
    this.#name = name;
  }

  // name은 접근자 프로퍼티다.
  get name() {
    // private 필드를 참조하여 trim한 다음 반환한다.
    return this.#name.trim();
  }
}

const me = new Person(' Lee ');
console.log(me.name); // Lee
```

<br>


#### 예제 25-52: private field는 반드새 클래스 몸체에 정의해야 한다<br>직접 constructor에 정의하면 Error 발생

```javascript
class Person {
  constructor(name) {
    // private 필드는 클래스 몸체에서 정의해야 한다.
    this.#name = name;
    // SyntaxError: Private field '#name' must be declared in an enclosing class
  }
}
```
* SyntaxError 설명이 꽤 직관적임

<br>

### 25.7.5 static 필드 정의 제안
* 2021.1 기준 '최신' 버전 기준으로 구현된 상태

#### 예제 25-53
```Javascript
class MyMath {
    // static public field 정의
    static PI = 22 / 7;
    
    // static private field 정의
    static #num = 10;
    
    // static method
    static increment() {
        return ++MyMath.#num;
    }
}

console.log(MyMath.PI); // 3.142857142857143
console.log(MyMath.increment()); // 11
```

<br>

## 25.8 상속에 의한 클래스 확장


### 25.8.1 클래스 상속과 생성자 함수 상속

* 지금까지 살펴본 프로토타입 기반 상속과는 다른 개념
* 기존 클래스를 상속받아 새로운 클래스를 확장(extends)하여 정의

#### 그림 25-7: 상속에 의한 클래스 확장
![img_6.png](shi_images%2Fimg_6.png)

<br>

#### 그림 25-8: 클래스 상속 -> 클래스의 속성을 상속받음
![img_7.png](shi_images%2Fimg_7.png)

<br>

#### 예제 25-54: 그림 25-8에서 나온 Bird class를 구현해 보자 *(상속을 통해 Animal class를 확장했다는 게 포인트)*
```Javascript
class Animal {
    constructor(age, weight) {
        this.age = age;
        this.weight = weight;
    }
    
    eat() {
        return 'eat';
    }
    
    move() {
        return 'move';
    }
}

// Animal 기본 속성 가지되 fly()가 추가된 class
// 상속을 받은 걸 고려하면 기본 fly() 가진 상태에서 Animal 고유 속성 이식받았다는 게 더 맞는 표현?
class Bird extends Animal {
    fly() {
        return 'fly';
    }
}

const bird = new Bird(1, 5); // 여기서 주는 인자는 age = 1, weight = 5

console.log(bird); // Bird {age: 1, weight: 5}
console.log(bird instanceof Bird); // true
console.log(bird instanceof Animal); // true

// Animal class에서 정의한 method와 Bird class 에서 정의한 method 모두 access 가능
console.log(bird.eat()); // eat
console.log(bird.move()); // move
console.log(bird.fly()); // fly
```

<br>

#### 그림 25-9: 상속에 의해 확장된 클래스 Bird에 의해 생성된 인스턴스의 프로토타입 체인
![img_8.png](shi_images%2Fimg_8.png)

<br>

* 클래스는 `extends` 키워드가 기본적으로 제공됨
  * 해당 키워드를 사용한 클래스 확장은 간편하고 직관적
* 하지만 생성자 함수는 클래스처럼 상속 -> 다른 생성자 함수를 확장할 수 있는 문법이 제공되지 않음

<br>

#### 예제 25-55: 의사 클래스 상속 패턴(참고용)
* 의사 클래스 상속 패턴을 사용하여 상속에 의한 클래스 확장 흉내 내기
* 클래스 이전 자바스크립트 전용
```Javascript
// 의사 클래스 상속(pseudo classical inheritance) 패턴
var Animal = (function () {
    function Animal(age, weight) {
        this.age = age;
        this.weight = weight;
    }

    Animal.prototype.eat = function () {
        return 'eat';
    };

    Animal.prototype.move = function () {
        return 'move';
    };

    return Animal;
}());

// Animal 생성자 함수를 상속하여 확장한 Bird 생성자 함수
var Bird = (function () {
    function Bird() {
        // Animal 생성자 함수에게 this와 인수를 전달하면서 호출
        Animal.apply(this, arguments);
    }

    // Bird.prototype을 Animal.prototype을 프로토타입으로 갖는 객체로 교체
    Bird.prototype = Object.create(Animal.prototype);
    // Bird.prototype.constructor을 Animal에서 Bird로 교체
    Bird.prototype.constructor = Bird;

    Bird.prototype.fly = function () {
        return 'fly';
    };

    return Bird;
}());

var bird = new Bird(1, 5);

console.log(bird); // Bird {age: 1, weight: 5}
console.log(bird.eat());  // eat
console.log(bird.move()); // move
console.log(bird.fly());  // fly 
```

<br>

### 25.8.2 extends 키워드

<br>

#### 예제 25-56: 상속을 통해 클래스를 확장할 시 `extends` 키워드를 통해 상속받을 클래스를 정의한다
```Javascript
class Base {} // 수퍼 클래스 (베이스/부모)

class Derived extends Base {} // 서브 클래스 (파생/자식)
```

#### 그림 25-10: extends 키워드
![img_9.png](shi_images%2Fimg_9.png)

<br>

### 25.8.3 동적 상속

<br>

#### 예제 25-57: extends 키워드로 생성자 함수를 상속받아 클래스를 확장할 수도 있지만, <br>extends 앞에는 반드시 *클래스*가 와야 한다

```javascript
// 생성자 함수
function Base(a) {
  this.a = a;
}

// 생성자 함수를 상속받는 서브클래스
class Derived extends Base {}

const derived = new Derived(1);
console.log(derived); // Derived {a: 1}
```
<br>

#### 예제 25-58: extends 다음에는 클래스뿐만 아니라 [[Construct]] 내부 메서드를 가지는, 함수 객체로 평가 가능한 모든 표현식을 사용 가능<br>이 녀석을 통해 상속 대상을 동적으로 결정 가능

```javascript
function Base1() {}

class Base2 {}

let condition = true;

// 조건에 따라 동적으로 상속 대상을 결정하는 서브클래스
class Derived extends (condition ? Base1 : Base2) {}

const derived = new Derived();
console.log(derived); // Derived {}

console.log(derived instanceof Base1); // true
console.log(derived instanceof Base2); // false
```

<br>


### 25.8.4 서브클래스의 constructor

<br>

#### 예제 25-59: 클래스에서 constructor를 생략하면? 비어있는 constructor가 *암묵적으로* 정의된다

```javascript
constructor() {}
```

<br>

#### 예제 25-60: 서브클래스에서 constructor를 생략하면? 이쪽도 constructor가 *암묵적*으로 정의된다<br>* `args` = `new`연산자와 함께 클래스를 호출할 때 전달한 인수 리스트 (arguments)

```javascript
constructor(...args) { super(...args); }
```

<br>

> super()는 수퍼클래스의 constructor(= super-constructor)를 호출하여 인스턴스를 생성한다.
> ***
> > Rest 파라미터
> > ***
> > * 매개변수에 `...`을 붙이면 Rest 파라미터가 된다
> > * 함수에 전달된 인수들의 목록을 배열로 전달받는다

<br>

#### 예제 25-61: 수퍼클래스, 서브클래스 모두 `constructor`를 생략함

```javascript
// 수퍼클래스
class Base {}

// 서브클래스
class Derived extends Base {}
```

<br>

#### 예제 25-62: 위 예제의 클래스에서 어떻게 암묵적으로 constructor가 정의되는지 정리

```javascript
// 수퍼클래스
class Base {
  constructor() {}
}

// 서브클래스
class Derived extends Base {
  constructor() { super(); }
}

const derived = new Derived();
console.log(derived); // Derived {}
```
* 수퍼클래스, 서브클래스 모두 constructor 생략시 빈 객체 생성
* 프로퍼티 소유하는 인스턴스를 생성하려면 *constructor 내부*에서 *인스턴스에 프로퍼티를 추가*해야 함

<br>

### 25.8.5 super 키워드

* 함수처럼 호출도 할 수 있고
* 식별자처럼 참조할 수도 있는 특수한 키워드(`this`처럼)

#### 동작 방식
1. `super` 호출 → 수퍼클래스 constructor(super-constructor) 호출
2. `super` 참조 → 수퍼클래스 메서드 호출 가능

<br>

#### `super` 호출: `super`를 호출하면 수퍼클래스의 constructor(super-constructor)를 호출한다

<br>

#### 예제 25-63: 수퍼클래스 constructor 내부에서 추가한 프로퍼티를 그대로 갖는 인스턴스를 생성한다면 서브클래스의 constructor 생략 가능

```javascript
// 수퍼클래스
class Base {
  constructor(a, b) {
    this.a = a;
    this.b = b;
  }
}

// 서브클래스
class Derived extends Base {
  // 다음과 같이 암묵적으로 constructor가 정의된다.
  // constructor(...args) { super(...args); }
}

const derived = new Derived(1, 2); // new 연산자와 함께 서브클래스를 호출하면서 전달한 인수는 
// 모두 서브클래스에 암묵적으로 정의된 constructor의 super 호출을 통해 super class의 constructor까지 전달됨
console.log(derived); // Derived {a: 1, b: 2}
```

<br>

#### 예제 25-64: 수퍼클래스에서 추가한 프로퍼티와 서브클래스에서 추가한 프로퍼티를 갖는 인스턴스를 생성한다면 서브클래스 constructor 생략 불가

```javascript
// 수퍼클래스
class Base {
  constructor(a, b) { // ④
    this.a = a;
    this.b = b;
  }
}

// 서브클래스
class Derived extends Base {
  constructor(a, b, c) { // ②
    super(a, b); // ③
    this.c = c;
  }
}

const derived = new Derived(1, 2, 3); // ① // 1 -> 2 -> 3 -> 4 순으로 전달됨
console.log(derived); // Derived {a: 1, b: 2, c: 3}
```

<br>

### `super` 호출시 주의할 사항

<br>

#### (1) 예제 25-65: 서브클래스에서 constructor를 생략하지 않는 경우 서브클래스의 constructor에서는 반드시 super를 호출해야 함

```javascript
class Base {}

class Derived extends Base {
  constructor() {
    // ReferenceError: Must call super constructor in derived class 
      // before accessing 'this' or returning from derived constructor
    console.log('constructor call');
  }
}

const derived = new Derived();
```

<br>

#### (2) 예제 25-66: 서브클래스 constructor에서 super를 호출하기 전에는 this 참조 불가

```javascript
class Base {}

class Derived extends Base {
  constructor() {
    // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
    this.a = 1;
    super(); // super가 먼저 와야 함
  }
}

const derived = new Derived(1);
```

<br>

#### (3) 예제 25-67: super는 반드시 서브클래스의 constructor에서만 호출하며, 서브클래스가 아닌 클래스의 constructor나 함수에서 super 호출시 에러 발생

```javascript
class Base {
  constructor() {
    super(); // SyntaxError: 'super' keyword unexpected here
  }
}

function Foo() {
  super(); // SyntaxError: 'super' keyword unexpected here
}
```

<br>

### `super` 참조: 메서드 내에서 `super`를 참조하면 수퍼클래스의 메소드를 호출 가능

<br>

#### (1) 예제 25-68: 서브클래스 프로토타입 메서드 내에서 `super.sayHi`는 수퍼클래스 프로토타입 메서드 `sayHi`를 가리킴

```javascript
// 수퍼클래스
class Base {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    return `Hi! ${this.name}`;
  }
}

// 서브클래스
class Derived extends Base {
  sayHi() {
    // super.sayHi는 수퍼클래스의 프로토타입 메서드를 가리킨다.
    return `${super.sayHi()}. how are you doing?`;
  }
}

const derived = new Derived('Lee');
console.log(derived.sayHi()); // Hi! Lee. how are you doing?
```

<br>

#### 예제 25-69: super 참조를 통해 수퍼클래스 메서드 참조하려면 super가 수퍼클래스의 메서드가 바인딩된 객체(=수퍼클래스의 prototype 프로톹타입에 바인딩된 프로토타입)를(을) 참조할 수 있어야 한다.<br><small>(예제 25-68과 동일하게 동작)</small>

```javascript
// 수퍼클래스
class Base {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    return `Hi! ${this.name}`;
  }
}

class Derived extends Base {
  sayHi() {
    // __super는 Base.prototype을 가리킨다.
    const __super = Object.getPrototypeOf(Derived.prototype);
    return `${__super.sayHi.call(this)} how are you doing?`;
  }
}
```

<br>

#### 예제 25-70: super는 자신을 참조하는 메서드의 프로토타입을 가리킨다.<br>그러므로 Base.prototype.sayHi를 호출할 때 call 메서드를 사용해 this를 전달해야 한다.

```javascript
/*
[[HomeObject]]는 메서드 자신을 바인딩하고 있는 객체를 가리킨다.
[[HomeObject]]를 통해 메서드 자신을 바인딩하고 있는 객체의 프로토타입을 찾을 수 있다.
예를 들어, Derived 클래스의 sayHi 메서드는 Derived.prototype에 바인딩되어 있다.
따라서 Derived 클래스의 sayHi 메서드의 [[HomeObject]]는 Derived.prototype이고
이를 통해 Derived 클래스의 sayHi 메서드 내부의 super 참조가 Base.prototype으로 결정된다.
따라서 super.sayHi는 Base.prototype.sayHi를 가리키게 된다.
*/
super = Object.getPrototypeOf([[HomeObject]])
```
* call 메서드를 통해 this를 전달하지 않고 Base.prototype.sayHi를 그대로 호출하면?
  * 프로토타입 메서드라서 내부의 this는 Base.prototype이 아닌 인스턴스를 가리켜야 한다
    * name 프로퍼티는 인스턴스에 존재한다
* super 참조가 동작하기 위해서는 super를 참조하는 메서드가 바인딩된 객체의 프로토타입을 찾을 수 있어야 한다
  * 이를 위해 메서드는 내부 슬롯 [[HomeObject]]를 가지며, 자신을 바인딩하는 객체를 가리킨다 

<br>

#### 예제 25-71: (주의) ES6 메서드 축약 표현으로 정의된 함수만 [[HomeObject]]를 가진다.

```javascript
const obj = {
  // foo는 ES6의 메서드 축약 표현으로 정의한 메서드다. 따라서 [[HomeObject]]를 갖는다.
  foo() {},
  // bar는 ES6의 메서드 축약 표현으로 정의한 메서드가 아니라 일반 함수다.
  // 따라서 [[HomeObject]]를 갖지 않는다.
  bar: function () {}
};
```

<br>

#### 예제 25-72 
* [[HomeObject]]를 가지는 함수(=ES6 메서드 축약 표현으로 정의된 함수)만 super 참조 가능
    * 클래스 전유물 아님
    * 객체 리터럴에서도 super 참조 사용 가능
```javascript
const base = {
  name: 'Lee',
  sayHi() {
    return `Hi! ${this.name}`;
  }
};

const derived = {
  __proto__: base,
  // ES6 메서드 축약 표현으로 정의한 메서드다. 따라서 [[HomeObject]]를 갖는다.
  sayHi() {
    return `${super.sayHi()}. how are you doing?`;
  }
};

console.log(derived.sayHi()); // Hi! Lee. how are you doing?
```

<br>

#### 예제 25-73: 서브클래스 정적 메서드 내의 super.sayHi는 수퍼클래스의 정적 메서드 sayHi를 가리킴

```javascript
// 수퍼클래스
class Base {
  static sayHi() {
    return 'Hi!';
  }
}

// 서브클래스
class Derived extends Base {
  static sayHi() {
    // super.sayHi는 수퍼클래스의 정적 메서드를 가리킨다.
    return `${super.sayHi()} how are you doing?`;
  }
}

console.log(Derived.sayHi()); // Hi! how are you doing?
```

<br>

### 25.8.6 상속 클래스의 인스턴스 생성 과정

<br>

### 25.8.7 표준 빌트인 생성자 함수 확장

<br>


