# 38. 브라우저의 렌더링 과정

> ***파싱(parsing)***
> ***
> * = 구문 분석(syntax analysis)
> * text 문자열을 token으로 분해(어휘 분석lesical analysis)한 뒤, 문법적 의미와 구조를 반영하여 토큰에 parse tree/syntax tree를 생성하는 일련의 과정
> * 일반적으로 parsing이 완료된 이후에는 parse tree를 기반으로 중간 언어(intermediate code)인 bytecode를 생성하고 실행

> ***렌더링(rendering)***
> ***
> HTML, CSS, Javascript로 작성된 문서를 parsing하여 browser에 시각적으로 출력하는 것
> * 브라우저 시각화를 위한 parsing의 일종?

<br>

#### 브라우저의 렌더링 과정(critical rendering path)
<img src="shi_images\img.png" width="100%">

1. 브라우저가 렌더링에 필요한 리소스를 서버에 요청하고 응답을 받음
   * 렌더링에 필요한 resource: HTML, CSS, Javascript, image file(s), font file(s), etc...
2. 브라우저 렌더링 엔진은 서버에서 response로 받은 HTML과 CSS를 parsing하여 DOM, CSSOM을 생성한 뒤 이들을 결합하여 렌더 트리를 생성
3. 브라우저 Javascript engine은 서버에서 응답받은 javascript를 parsing하여 Abstract Syntax Tree를 생성한 뒤 바이트코드로 변환하여 실행함. 자바스크립트는 DOM API를 통해 DOM/CSSOM을 변경할 수 있고, 변경된 DOM과 CSSOM은 다시 render tree로 결합됨
4. render tree를 기반으로 HTML 요소의 layout을 계산한 뒤 browser 화면에 HTML 요소를 painting함
   * 레이아웃(layout): 위치와 크기

<br>

## 38.1 요청과 응답

> 브라우저의 핵심 기능
> ***
> 필요한 resource를 server에 request하고 server에서 받은 response를 browser에 시각적으로 rendering하는 것
> * rendering에 필요한 resource는 모두 server에 존재함 <br>☞ 그러므로 필요한 resource를 server에 요청하고 응답한 resource를 parsing하여 rendering하는 것

<br>

#### 서버에 요청을 전송하기 위해 식별용 *주소*가 필요 → 브라우저는 주소창 제공
<figure>
<img src="shi_images\img_1.png" width="100%">
<figcaption>URI: Uniform Resource Identifier</figcaption>
</figure>
1. 브라우저의 주소창에 URL 입력
2. 엔터 키 누름
3. URL host name이 DNS를 통해 IP주소로 변환
4. 해당 IP주소를 갖는 server에게 요청을 전송함

<br>

##### (예시) 브라우저의 주소창에 https://poiemaweb.com 을 입력하고 엔터 키를 누른다면? 

1. 루트 요청이 poiemaweb.com 서버로 전송됨
   * 루트 요청: /, scheme과 host만으로 구성된 URI에 의한 요청
2. 명확한 resource를 요청하는 내용이 없으면 암묵적으로(default) index.html(https://poiemaweb.com/index.html) 응답
3. 명확한 resource를 요청하려면 브라우저의 주소창에 요청할 정적 파일의 경로와 파일 이름을 URI 호스트 뒤의 path에 기술하여 서버에 요청
   * (예) https://poiemaweb.com URI host 뒤에 /assets/data/data.json path와 파일 이름까지 기술<br>이 경우엔 aseets/data 폴더 내에 있는 정적 파일 data.json 응답할 것

<br>

#### 비단 주소창뿐만이 아니라 자바스크립트를 통해 동적으로 서버에 정적/동적 데이터를 요청하는 것도 가능

<br>

#### 요청과 응답은 개발자 도구의 Network 패널에서 확인 가능

1. 브라우저의 주소창에 https://poiemaweb.com 입력
2. 엔터 키를 눌러서 서버에 루트 요청 전송
3. 브라우저가 poiemaweb.com 서버에 요청한 내용, 서버가 응답한 내용을 개발자 도구 Network 패널에서 확인 가능
   * 개발자 도구 Network 패널을 활성화하기 전에 브라우저가 이미 응답을 받았다면 응답된 리소스가 표시되지 않음<br>이 경우엔 페이지를 새로고침해야 Network 패널에서 request, response내역 확인 가능
4. response엔 HTML뿐만 아니라 CSS, Javascript, image file, font file 등도 포함
   * 브라우저 렌더링 엔진이 HTML(index.html)를 parsing하는 도중에 각종 태그들을 만나면 HTML parsing을 일시 중단하고 해당 tag에서 가리키는 resource file을 서버로 요청
   <img src="shi_images\img_2.png" width="100%">

<br>

## 38.2 HTTP 1.1과 HTTP 2.0

> HTTP(HyperText Transfer Protocol)
> ***
> 웹에서 브라우저와 서버가 통신하기 위한 프로토콜(규약)
> * 1989년 팀 버너스 리 경이 HTML, URL과 함께 고안
> * 1991년 최초로 문서화
> * 1996년 HTTP/1.0 발표
> * 1999년 HTTP/1.1 발표
> * 2015년 HTTP/2 발표

#### HTTP/1.1 vs HTTP/2
| HTTP/1.1                                                       | HTTP/2                                                         |
|:---------------------------------------------------------------|:---------------------------------------------------------------|
| <img src="shi_images\img_3.png" width="100%">                  | <img src="shi_images\img_4.png" width="100%">                  |
| connection당 하나의 request, response만 처리<br>여러 개의 요청/응답 한번에 처리 불가 | connection당 다수의 요청/응답 가능                                       |
| 요청할 resource 개수 비례하여 응답 시간도 증가                                 | 요청할 리소스 개수에 응답 시간 비례하지 않음<br>HTTP/1.1에 비해 페이지 로드 속도가 50% 정도 빠름 |

<br>

## 38.3 HTML 파싱과 DOM 생성

> ***DOM은 HTML문서를 parsing한 결과물이다***
> ***
> 브라우저 요청 -> 서버 응답 -> HTML 문서: 순수한 텍스트
> ***
> 이렇게 응답받은 HTML(순수 text) -> ***브라우저가 이해할 수 있는 자료구조(객체, DOM:Document Object Model)로 변환*** -> 메모리에 저장 -> 브라우저에 시각적인 pixel로 rendering

<br>

#### (예) 예제 38-01에 기술된 index.html이 서버로부터 response로 왔을 때<br>☞ 브라우저 렌더링 엔진은 어떤 식으로 일을 해서 이 HTML으로 DOM을 생성할까?
#### 예제 38-01: index.html (예제)
```HTML
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script src="app.js"></script>
  </body>
</html>
```

<br>

<figure>
   <img src="shi_images\img_5.png" width="100%">
   <figcaption>HTML parsing & DOM 생성</figcaption>
</figure>

1. 서버에 존재하던 HTML 파일이 브라우저의 요청(request)에 의해 응답(response)된다.
   1. 서버는 브라우저가 요청한 HTML 파일을 읽어들여 메모리에 저장
   2. 메모리에 저장된 바이트(2진수)를 인터넷을 경유하여 응답
2. 브라우저는 서버가 응답한 HTML 문서를 바이트(2진수) 형태로 응답받음
   1. 응답된 바이트 형태의 HTML 문서는 meta tag의 charset attribute에 의해 지정된 인코딩 방식(예: UTF-8)을 기준으로 문자열로 변환
      * 이 인코딩 방식은 응답 헤더(response header)에 담겨 응답됨(예: content-type: text/html; charset=utf-8)
   2. 브라우저는 이를 확인하고 문자열로 변환
3. 문자열로 변환된 HTML를 읽어들여 문법적 의미를 갖는 코드의 최소 단위인 토큰(token)들로 분해
4. 각 토큰들을 객체로 변환하여 노드(node)들을 생성
   * 토큰의 내용에 따라 문서/요소/attribute/텍스트 노드 생성
   * 노드는 이후 DOM을 구성하는 기본 요소가 됨
5. HTML 문서는 HTML 요소들의 집합으로 이루어지며 HTML요소는 중첩 관계를 가짐<br>즉, HTML 요소의 contents 영역(시작 태그 ~ 종료 태그 사이)에는 텍스트뿐만 아니라 다른 HTML 요소도 포함 가능
   1. HTML 요소 간에는 중첩 관계에 의해 부자 관계 형성
   2. HTML 요소간 부자 관계 반영하여 모든 노드들을 *트리 자료구조*로 구성
   * 이 노드들로 구성된 tree 자료구조를 Document Object Model(DOM)이라 부름


## 38.4 CSS 파싱과 CSSOM 생성

<br>

## 38.5 렌더 트리 생성

<br>

## 38.6 자바스크립트 파싱과 실행

<br>

## 38.7 리플로우와 리페인트

<br>

## 38.8 자바스크립트 파싱에 의한 HTML 파싱 중단

<br>

## 38.9 script 태그의 async/defer 어트리뷰트

<br>
