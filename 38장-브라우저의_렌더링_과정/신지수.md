브라우저 렌더링 엔진은 HTML, CSS, Javascript를 해석하여 사용자가 볼 수 있는 웹페이지를 화면에 표시하는 역할을 합니다.

이 과정은 여러 단계를 거쳐 이루어지며, 각각의 단계에서 최적화가 가능하여 웹페이지의 성능을 향상시킬 수 있습니다.

### 브라우저 렌더링 엔진의 작동 과정

1. HTML 파싱 및 DOM 트리 생성 : 브라우저는 HTML 문서를 받아들여 이를 파싱하여 DOM트리를 생성합니다. DOM 은 HTML문서의 구조를 계층적으로 표현한 것입니다.
2. CSS 파싱 및 CSSOM 트리 생성 : 브라우저는 CSS를 파싱하여 CSSOM트리를 만듭니다. 이 트리는 스타일 규칙과 HTML요소를 연결하여 어떤 스타일이 적용될지를 결정합니다.
3. 렌더 트리 생성 : DOM과 CSSOM 트리를 결합하여 렌더 트리를 생성합니다. 렌더 트리는 화면에 실제로 표시될 요소들로 구성되며, 보이지 않는 요소 (`display: none;`으로 숨겨진 요소)는 포함되지 않습니다.
4. 레이아웃(리플로우) : 렌더 트리의 각 노드가 화면의 어느 위치에 배치될지를 계산합니다. 이 과정에서 요소들의 크기와 위치가 결정됩니다.
    - **리플로우(Reflow)**: DOM 구조나 요소의 레이아웃에 변동이 생길 때 발생합니다. 예를 들어, 창 크기를 조정하거나, 콘텐츠를 추가/삭제하는 경우가 이에 해당합니다. 리플로우는 화면의 재배치를 수반하므로 성능에 큰 영향을 미칠 수 있습니다. 리플로우가 일어나면, 그 이후 단계로 리페인트가 이어집니다.
5. 페인팅(리페인트) : 계산된 레이아웃을 바탕으로 각 요소가 화면에 그려집니다. 이 단계에서 색상, 텍스처, 그림자 등이 스타일이 적용됩니다.
    - **리페인트(Repaint)**: 요소의 위치나 크기는 변하지 않고, 색상이나 배경 이미지와 같은 스타일 속성만 변경될 때 발생합니다. 리페인트는 리플로우보다 덜 비용이 많이 드는 작업이지만, 여전히 성능에 영향을 미칩니다.
6. 합성 : 그려진 요소들이 레이어로 나위어 합성됩니다. 이 과정은 GPU를 활용해 이루어지며, 여러 레이어를 조합하여 최종 화면을 생성합니다.

### **리플로우와 리페인트 최소화 방법**

1. **DOM 조작 최소화**: DOM 조작을 최소화하고, 변경 사항을 한 번에 적용합니다. 예를 들어, 여러 스타일을 개별적으로 변경하기보다는 CSS 클래스를 추가/제거하는 방식으로 한꺼번에 적용할 수 있습니다.
2. **배치 계산을 캐싱**: 요소의 레이아웃 정보를 반복적으로 접근할 경우, 중간에 변경이 없으면 캐싱하여 재계산을 피하는 것이 좋습니다.
3. **CSS 속성 활용**: 리플로우를 유발하지 않는 CSS 속성(`transform`, `opacity`)을 활용하여 애니메이션이나 스타일 변경을 수행합니다. 예를 들어, `transform: translateX()`를 사용하면 레이아웃이 변경되지 않으므로 리플로우가 발생하지 않고, 리페인트만 발생합니다.
4. **동적 콘텐츠 업데이트 최소화**: 콘텐츠를 자주 변경하는 경우, 이를 DOM의 특정 부분에만 적용하도록 하여 전체 페이지의 리플로우를 방지합니다. 예를 들어, `position: absolute` 또는 `fixed`를 사용하면 해당 요소가 독립적으로 동작하므로 리플로우가 다른 요소에 미치는 영향을 줄일 수 있습니다.
5. **플로우 트리거링 속성 피하기**: `width`, `height`, `margin`, `padding` 등의 속성은 리플로우를 트리거할 가능성이 높습니다. 이러한 속성의 변경은 최소화하고, 가능하다면 초기 스타일 선언 시에만 설정하도록 합니다.
6. **요소의 가시성 제어**: 요소를 보이지 않게 할 때 `visibility: hidden;`을 사용하면 리플로우가 발생하지 않지만, `display: none;`을 사용하면 리플로우가 발생합니다. 상황에 맞게 적절한 속성을 선택하는 것이 중요합니다.