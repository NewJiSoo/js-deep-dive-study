# 26. ES6 함수의 추가 기능

## 26.1 함수의 구분

#### 예제 26-01: ES6 이전 함수는 동일한 함수라도 다양한 형태로 호출 가능
```Javascript
var foo = function () {
  return 1;
};

// 일반적인 함수로서 호출
foo(); // -> 1

// 생성자 함수로서 호출
new foo(); // -> foo {}

// 메서드로서 호출
var obj = { foo: foo };
obj.foo(); // -> 1
```

* 일반 함수로서 호출하는 건 물론이고 생성자 함수로서도 호출 가능
  * callable에다 constructor

#### 예제 26-02: callable & constructor
```Javascript
var foo = function () {};

// ES6 이전의 모든 함수는 callable이면서 constructor다.
foo(); // -> undefined
new foo(); // -> foo {}
```

<br>

> callable & constructor/non-constructor
> ***
> * 호출할 수 있는 함수 객체: callable
> ***
> * 인스턴스를 생성할 수 있는 함수 객체: constructor
> * 인스턴스 생성 불가 함수 객체: non-constructor

<br>

#### 예제 26-03: ES6이전, 일반적으로 메서드라고 부르던 객체에 바인딩된 함수도 callable & constructor<br>객체 바인딩된 함수도 callable & constructor
```Javascript
// 프로퍼티 f에 바인딩된 함수는 callable이며 constructor다.
var obj = {
  x: 10,
  f: function () { return this.x; }
};

// 프로퍼티 f에 바인딩된 함수를 메서드로서 호출
console.log(obj.f()); // 10

// 프로퍼티 f에 바인딩된 함수를 일반 함수로서 호출
var bar = obj.f;
console.log(bar()); // undefined

// 프로퍼티 f에 바인딩된 함수를 생성자 함수로서 호출
console.log(new obj.f()); // f {}
```

* 객체에 바인딩된 함수를 생성자 함수로 호출하면 성능 면에서 문제가 있음...
  * prototype property를 가짐
  * prototype 객체도 생성
  * (예) callback 함수도 constructor -> (불필요한) prototype 객체 생성

#### 예제 26-04: 위에서 나온 불건전한 callback 함수의 사례?
```Javascript
// 콜백 함수를 사용하는 고차 함수 map. 콜백 함수도 constructor이며 프로토타입을 생성한다.
[1, 2, 3].map(function (item) {
  return item * 2;
}); // -> [ 2, 4, 6 ]
```

* 이와 같은 문제를 해결하기 위해 ES6에서는 함수를 사요 ㅇ 목적에 따라 세 가지 종류로 명확히 구분함
#### 표
![img.png](shi_images%2Fimg.png)


<br>

## 26.2 메서드

#### ES6 이전: 메서드에 대한 명확한 정의 없었음(일반적으로 객체에 바인딩된 함수를 일컬음)
#### ES6사양: 메서드는 메서드 축약 표현으로 정의된 함수만을 의미

#### 예제 26-05: ES6 버전 메서드 구분
```Javascript
const obj = {
  x: 1,
  // foo는 메서드이다.
  foo() { return this.x; },
  // bar에 바인딩된 함수는 메서드가 아닌 일반 함수이다.
  bar: function() { return this.x; }
};

console.log(obj.foo()); // 1
console.log(obj.bar()); // 1
```

<br>

#### 예제 26-06: ES6에서 정의한 메서드는 인스턴스 생성 불가 non-constructor다
```Javascript
new obj.foo(); // -> TypeError: obj.foo is not a constructor
new obj.bar(); // -> bar {}
```

<br>

#### 예제 26-07: 그러므로 ES6 메서드는 prototype property도 없고 prototype을 생성하지도 않는다
```Javascript
// obj.foo는 constructor가 아닌 ES6 메서드이므로 prototype 프로퍼티가 없다.
obj.foo.hasOwnProperty('prototype'); // -> false

// obj.bar는 constructor인 일반 함수이므로 prototype 프로퍼티가 있다.
obj.bar.hasOwnProperty('prototype'); // -> true
```

#### 예제 26-08: 표준 빌트인 객체가 제공하는 프로토타입 메서드 & 정적 메서드는 모두 non-constructor
```Javascript
String.prototype.toUpperCase.prototype; // -> undefined
String.fromCharCode.prototype           // -> undefined

Number.prototype.toFixed.prototype; // -> undefined
Number.isFinite.prototype;          // -> undefined

Array.prototype.map.prototype; // -> undefined
Array.from.prototype;          // -> undefined
```

<br>

#### 예제 26-09: ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 ***[[HomeObject]]***를 가짐
* super 참조는 이쪽 내부 슬롯을 사용하여 수퍼클래스의 메서드를 참조함
* 내부 슬롯 [[HomeObject]]를 갖는 ES6 메서드는 키워드 사용 가능
```Javascript
const base = {
    name: 'Lee',
    sayHi() {
        return `Hi! ${this.name}`;
    }
};

const derived = {
    __proto__: base,
    // sayHi는 ES6 메서드다. ES6 메서드는 [[HomeObject]]를 갖는다.
    // sayHi의 [[HomeObject]]는 sayHi가 바인딩된 객체인 derived를 가리키고
    // super는 sayHi의 [[HomeObject]]의 프로토타입인 base를 가리킨다.
    sayHi() {
        return `${super.sayHi()}. how are you doing?`;
    }
};

console.log(derived.sayHi()); // Hi! Lee. how are you doing?
```

<br>

#### 예제 26-10: ES6 메서드 아닌 함수는 super 키워드 사용 불가: 내부 슬롯 [[HomeeObject]]가 없기 때문
```Javascript
const derived = {
  __proto__: base,
  // sayHi는 ES6 메서드가 아니다.
  // 따라서 sayHi는 [[HomeObject]]를 갖지 않으므로 super 키워드를 사용할 수 없다.
  sayHi: function () {
    // SyntaxError: 'super' keyword unexpected here
    return `${super.sayHi()}. how are you doing?`;
  }
};
```

> ES6 메서드는
> 1. 본연의 기능(super)추가
> 2. 의미 면에서 맞지 않는 기능(constructor)는 제거
> ***
> 따라서 메서드 정의시 프로퍼티 값으로 익명 함수 표현식을 할당하는 ES6 이전 방식은 지양하는 편이 좋다


<br>


## 26.3 화살표 함수
### 26.3.1 화살표 함수 정의
### 26.3.2 화살표 함수와 일반 함수의 차이
### 26.3.3 this
### 26.3.4 super
### 26.3.5 arguments
## 26.4 Rest 파라미터
### 26.4.1 기본 문법
### 26.4.2 Rest 파라미터와 arguments 객체
## 26.5 매개변수 기본값

