# 21. 빌트인 객체
## 21.1 자바스크립트 객체의 분류

| 표준 빌트인 객체<br>standard built-in objects<br>native objects<br>global objects | 호스트 객체<br>host objects                                                                                                                                                                                 | 사용자 정의 객체<br>user-defined objects |
|:---------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------|
| ECMAScript사양에 정의된 객체<br>애플리케이션 전역의 공통 기능을 제공                               | ECMAScript 사양X<br>자바스크립트 실행 환경에서 추가로 제공하는 객체<br>(자바스크립트 실행환경: 브라우저/Node.js)                                                                                                                            | 사용자가 직접 정의한 객체                    |
| Javascript 실행 환경과 관계없이 언제나 사용 가능                                           | 브라우저 환경이 제공하는 호스트 객체: 클라이언트 사이트 Web API<br>(예: DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker)<br>Node.js 환경이 제공하는 호스트 객체: Node.js 고유 API |                                   |
| 전역 객체의 프로퍼티로서 제공                                                           |                                                                                                                                                                                                        |                                   |

## 21.2 표준 빌트인 객체

#### 1. Javascript는 약 40여 개의 표준 빌트인 객체를 제공한다.
#### 2.거의 모든 표준 빌트인 객체는 인스턴스를 생성할 수 있는 *생성자 함수 객체*다.
* 생성자 함수 객체인 표준 빌트인 객체
  * 프로토타입 메서드와 정적 메소드 제공
  * Math, Reflect, JSON 제외한 표준 빌트인 객체
  ##### 예제 21-01: 생성자 함수로 호출하여 인스턴스를 생성할 수 있는 표준 빌트인 객체<br>(예: String, Number, Boolean, Function, Array, Date)<br>function만 빼고 죄다 object
  ```Javascript
  const strObj = new String('Lee'); // String {"Lee"}
  console.log(typeof strObj); // object 
  
  const numObj = new Number(123); // Number {123}
  console.log(typeof numObj); // object
  
  const boolObj = new Boolean(true); // Boolean {true}
  console.log(typeof boolObj); // object
  
  const func = new Function('x', 'return x * x'); // f anonymous(x )
  console.log(typeof func); // function
  
  const arr = new Array(1, 2, 3); // (3) [1, 2, 3]
  console.log(typeof arr); // object
  
  const regExp = new RegExp(/ab_c/i); // /ab+c/i
  console.log(typeof regExp); // object
  
  const date = new Date(); // Mon September 02 2024 11:01:25 GMT+0900 (대한민국 표준시)
  console.log(typeof Date); // object
  ```  
* 생성자 함수 객체가 아닌 표준 빌트인 객체
  * 정적 메서드만 제공 
  * (예) Math, Reflect, JSON 객체

#### 3. 생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은<br>표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체다.
* (예) 표준 빌트인 객체 String 생성자 함수 → 호출 → String 인스턴스 생성 → 해당 인스턴스의 프로토타입은 String.prototype
    ##### 예제 21-02
    ```Javascript
    const strObj = new String('Lee'); // String {"Lee"}
    console.log(Object.getPrototypeOf(strObj) === String.prototype); // true
    ```

#### 4. 3.번에서 명시된 표준 빌트인 객체의 prototype 객체에 바인딩된 객체는 다양한 기능의 빌드인 *프로토타입 메서드*를 제공한다.<br>또한 표준 빌트인 객체는 인스턴스 없이도 호출 가능한 빌트인 *정적 메소드*를 제공한다.
* (예) 표준 빌트인 객체 Number의 prototype 프로퍼티에 바인딩된 객체, Number.prototype은
  1. 다양한 기능의 빌트인 프로토타입 메서드 제공
     * 이 프로토타입 메서드는 ***모든 Number 인스턴스가 상속을 통해 사용 가능***
  2. 인스턴스 없이 정적으로 호출 가능한 정적 메서드 제공
  ##### 예제 21-03
  ```Javascript
  const numObj = new Number(1.5); // Number {1.5} // Number 생성자 함수로 Number 객체 생성
  console.log(numObj.toFixed()); // 2 
  // toFixed는 (1) Number.prototype의 프로토타입 메서드이며 
  // (2) 소수점 자리를 반올림하여 문자열로 반환
  
  console.log(Number.isInteger(0.5)); // false 
  // isInteger는 (1) Number의 정적 메서드 (2) 인수의 정수 여부를 Boolean으로 반환 
  ```


## 21.3 원시값과 래퍼 객체

> ***래퍼 객체(wrapper object)***: 문자열/숫자/불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체
> ***
> 원시값을 객체처럼 사용한다? → 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환함<br>
> ☞ 문자열/숫자/불리언에 원시값이 있는데도 **객체 생성용 표준 빌트인 생성자 함수**가 존재하는 이유<br>(각각 String, Number, Boolean)

<br>

#### 예제 21-04: 원시값은 객체가 아닌데도 원시값인 문자열이 마치 객체처럼 동작한다? ☞ 래퍼 객체 때문
```Javascript
const str = 'hello'; // 문자열은 원시값인데도

// 마치 객체처럼 동작함: 이때 사용되는 게 원시값 전용 임시 객체 wrapper 객체
console.log(str.length); // 5
console.log(str.toUpperCase()); // HELLO
```

<br>

#### 예제 21-05: 문자열에 대해 마침표 표기법으로 접근하면 (1) 그 순간 wrapper 객체 인스턴스 생성<br>그리고 해당 문자열은 (2) 래퍼 객체의 \[\[타입 + Data\]\] 내부 슬롯에 할당됨
```Javascript
const str = 'hi'; // 원시 타입 문자열

// wrapper 객체 String 인스턴스 (자동) 변환
console.log(str.length); // 2
console.log(str.toUpperCase()); // HI

console.log(typeof str); // string // wrapper 객체로 프로퍼티에 접근/메서드 호출 이후, 다시 원시값으로 되돌림
```

<br>

* 문자열 래퍼 객체인 String 생성자 함수의 인스턴스는 String.prototype의 메서드를 상속받아 사용 가능
* 래퍼 객체의 처리가 종료되면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값으로 원래 상태로 되돌림<br>(즉, 식별자가 원시값을 가지는 상태 & 래퍼 객체는 garbage collection 대상)

#### 그림 21-1 문자열 래퍼 객체의 prototype chain
![img.png](shi_images%2Fimg.png)


<br>

#### 예제 21-06: Wrapper 객체에 프로퍼티를 지정해봤자... 문자열 편
```Javascript
const str = 'hello'; // 식별자 str은 문자열 hello를 값으로 지니고 있다.

// 식별자 str은 암묵적으로 생성된 래퍼 객체를 가리킨다.
// 위의 'hello'는 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 상태다.
str.name = 'Lee'; // 래퍼 객체에 name 프로퍼티가 추가된다.

// 식별자 str은 다시 원래 문자열 [[StringData]] 내부 슬롯에 할당된 원시값을 가지게 된다.
// str.name = 'Lee'; 에서 생성된 래퍼 객체는 아무도 참조하지 않게 되므로 가비지 컬렉션 대상이 된다.

console.log(str.name); // undefined // 식별자 str은 .name 이후에 새로 암묵적으로 생성된 래퍼 객체를 가리키기 때문
// 새롭게 생성되었기에 name 프로퍼티가 존재하지 않는다.

console.log(typeof str, str); // string hello
```
<br>

#### 예제 21-07: Wrapper 객체에 프로퍼티를 지정해봤자... 숫자 편
```Javascript
const num = 1.5; // 원시 타입(숫자) 식별자 num
console.log(num.toFixed()); // 2 // 이때 원시 타입 -> wrapper 객체(Number) 변환

// wrapper 객체로 프로퍼티 접근/메서드 호출 이후, !!다시 원시값으로 되돌린다!!
console.log(typeof num, num); // number 1.5
```

<br>

> 위와 같은 이유로, String, Number, Boolean 생성자 함수를 new 연산자와 함께 호출하여 문자열/숫자/ 불리언 인스턴스를 생성할 필요가 **없다**. 고로 권장하지도 않는다. 

<br>

#### ES6에서 새롭게 도입된 원시값 Symbol도 래퍼 객체를 생성한다.
 * 일반적인 원시값과는 달리 리터럴 표기법 생성X, Symbol 함수를 통해 생성해야 하므로 다른 원시값과는 차이가 있다.
 * Symbol은 생성자 함수가 아니므로 위 String/Number/Boolean 논의에서는 제외된다.

<br>

#### 문자열/숫자/불리언/심벌 이외의 원시값 = 즉 null 과 undefined는 래퍼 객체를 생성하지 않는다. <br>고로 null, undefined를 객체처럼 사용하면 에러가 발생한다.

<br>

## 21.4 전역 객체(global object)
### 21.4.1 빌트인 전역 프로퍼티
### 21.4.2 빌트인 전역 함수
### 21.4.3 암묵적 전역