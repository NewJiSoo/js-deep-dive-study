# 05장. 변수

***

### 5.1 값

> 값(value): 식(표현식expression)이 평가(evaluate)되어 생성된 결과
>   * **모든** 값은 **데이터 타입**을 가진다!!
> 평가: 식을 해석해서 값을 생성하거나 참조하는 것
> 변수: **하나의 값**을 저장하기 위해 확보한 메모리 공간 자체/메모리 공간 식별용 명칭
> ***
>       10 + 20; 
> ***
> * 여기서 '값value'은(는) 10과 20이 더해져서 나온 결과값 30
> * 10과 20을 더하는 행위가 '평가' 
> ***
>       var sum = 10 + 20;
> ***
> * 변수(sum)에 할당되는 것은 30이다
>   * !! 10 + 20이 할당되는 것이 아니다 !!

***

* 컴퓨터의 언어는 2진수 하나지만(메모리 저장 - 비트bit의 나열)
* 이 2진수는 데이터 타입에 따라 얼마든지 다양하게 표현될 수 있다.
  * 코딩테스트에서 자주 보이는 게 char과 int 사이를 왔다갔다 하는 거
  * (예) 0100 0001 2진수 = 2^6 + 1 = 65(10진수) = 아스키코드로 가면 'A'가 되어버림


***

### 5.2  리터럴

> 리터럴(literal): **사람**이 이해할 수 있는 문자 또는 약속된 기호로 값을 생성하는 표기법(notation)
> ***
>       3 // literally(영어 표현 - 문자 그대로), 숫자 3. 그래서 숫자 '리터럴'?
> ***
> * 자바스크립트 엔진은 코드가 실행되는 시점인 **런타임(runtime)**에 리터럴을 평가해 값을 생성한다.

***

* 리터럴로 표현하는 다양한 data type

|       리터럴        | 예시                             | 비고                                              |
|:----------------:|:-------------------------------|:------------------------------------------------|
|      정수 리터럴      | 100                            |                                                 |
|    부동소수점 리터럴     | 10.5                           |                                                 |
|     2진수 리터럴      | 0b01000001                     | 0b로 시작, b는 binary일 것                            |
|     8진수 리터럴      | 0o101                          | ES6에서 도입, 0o로 시작, o는 octave로 추정                 |
|     16진수 리터럴     | 0x41                           | ES6에서 도입, 0x로 시작,  <br/>x도 16진수스러운 무언가의 영단어로 추정 |
|     문자열 리터럴      | 'Hello'  <br/>"World"          | ''와 ""의 차이에 관해선 잘 모르겠음.                         |
| 불리언(boolean) 리터럴 | true  <br/>false               |                                                 |
|     null 리터럴     | null                           |                                                 |
|  undefined 리터럴   | undefined                      |                                                 |
|      객체 리터럴      | {name: 'Lee', address: 'Seoul' | JSON 포함?                                        |
|      배열 리터럴      | \[1, 2, 3\]                    |                                                 |
|      함수 리터럴      | function() {}                  | 직관적이어서 좋음                                       |
|    정규 표현식 리터럴    | /\[A-Z\]+/g                    |                                                 |


***

### 5.3 표현식

> 표현식(expression): 값으로 평가될 수 있는 문(statement)
> ***
> 표현식이 평가된다? = 새로운 값을 생성하거나 기존 값을 참조한다는 뜻  <br/>
> ☞ 나는 표현식이 '돌아간다'고 생각하는 게 직관적인 것 같음... 정확하진 않은 것 같지만  <br/>
> **값으로 평가될 수 있는 문은 모두 표현식이다.**
> ***
>> 동치(equation, =)  <br/>
>> 표현식 = 표현식이 평가된 값  <br/>
>> (예) 1 + 2 = 3;  <br/>var x = 1 + 2;  <br/>x + 3; // 표현식은 다른 표현식의 일부가 되어 새로운 값 만들어내기 가능
> ***
>       var score = 100;
> ***
> * 100은 (정수) 리터럴, 자바스크립트 엔진이 이것 자체만으로 평가를 진행해서 값을 생성함  <br/>그러므로 **리터럴은 그 자체로 표현식**이다...!  
> ***
>       var score = 50 + 50;
> ***
> * 50은 (정수) 리터럴
> * 연산자는 +
> * 50 + 50는 평가를 거쳐 숫자 값 100 생성, 고로 표현식
> ***
>       score; // 위의 예제에서 score 변수를 참조한 것
> ***
> 변수 식별자를 참조하면 변수 값으로 평가되므로 식별자 참조도 표현식이다!
***

<br>
* 리터럴 표현식


    10
    'Hello'


* 식별자 표현식(선언이 이미 존재한다고 가정)


    sum
    person.name
    arr[1]

* 연산자 표현식


    10 + 20
    sum = 10
    sum !== 10


* 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)


    square()
    person.getName()

***

### 5.4 문

> 문(statement): 프로그램을 구성하는 기본 단위이자 **최소 실행 단위**
> * 문의 집합 = 프로그램
> * 문을 작성하고 순서에 맞게 나열하는 것 = 프로그래밍
> ***
> * 문은 다수의 토큰으로 구성됨
>   * 토큰(token): 문법적으로 더는 나눌 수 없는 코드의 기본 요소(물론 문법적인 의미를 가진다)
>     * 국어의 형태소 같은 개념일까?
>     * (예) 키워드, 식별자, 연산자, 리터럴, 세미콜론(;)이나 마침표(.) 등의 특수문자
>     * (예2) (1 statement) var sum = 1 + 2; // 여기서 토큰을 나열해보면 (lots of tokens) var, sum, =, 1, +, 2, ;
> ***
> 문을 통해 컴퓨터에 명령을 내린다는 의미에서 문을 **명령문**이라고도 한다.
> 1. 문 실행
> 2. 명령 실행
> 3. '무언가'가 일어남
>    * 문 → 선언문
>      * 변수 선언문을 실행하면 변수가 선언되네?
>      * (예) var x;
>      * (예) function foo() {} // 얘는 함수 선언문임
>    * 문 → 할당분
>      * 할당문을 실행하면 값이 할당되네? 너무나 당연
>      * (예) x = 5;
>    * 문 → 조건문
>      * 조건에 따라 충족한 조건에서 지정한 코드 블록이 결정되어 그쪽 블록이 실행됨
>      * (예) if (x > 1) { console.log(x); }
>    * 문 → 반복문
>      * 특정 코드 블록이 반복 실행됨
>      * for (var i = 0; i < 2; i++) {console.log(i);}

***

### 5.5 세미콜론, 세미콜론 자동 삽입 기능

> 세미콜론(;): 문(statement)의 종료를 표시(누구에게? 자바스크립트 엔진에게!)
> * 단, 0개 이상의 문을 중괄호로 묶은 코드 블록 뒤에는 세미콜론을 붙이지 않음
>   * 중괄호 시리즈: {...} → if문, for문, 함수 등의 코드 블록 뒤에는 세미콜론을 붙이지 않음
>   * 이런 코드 블록 자체가 세미콜론 없이도 문의 종료를 의미하는 자체 종결성(self closing)을 지니기 때문
> * 자바스크립트에는 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)이 있어서 문의 끝이라고 예측되는 지점에 자바스크립트 엔진이 알아서 붙여줘서(암묵적 수행), statement의 끝에 붙이는 세미콜론은 옵션이다. 생략 가능하다.
>   * 그런데 이런 '자동' 기능은 항상 정확하지 않기 때문에 조심해야 한다

***
* 예제 05-10


    function foo() {
        return  (1) 세미콜론을 여기에 넣을 것이냐: ASI 동작 결과 
        {}      (2) 여기에 넣을 것이냐: 일반적인? 개발자의 예측
    }
    console.log(foo()); // (1)을 따라가니까 undefined 떠버림

    var bar = function () {}    // (1) 여기서 끊어서 볼 건지(개발자 예측)
    (function() {})();          // (2) 여기까지 이어서 bar로 볼 건지(ASI) → 그래서 TypeError: (intermediate value)(...) is not a function 나와버림

* 세미콜론 찬성파, 반대파 하는 주장 모두 일리가 있지만  <br/>일단 나는 세미콜론이 있어야 ASI와 개발자가 제대로 소통을 나눌 수 있을 것 같다...  <br/>책도 찬성파인 듯

***

### 5.6 표현식인/표현식이 아닌 문(statement)

> 표현식
> 1. 문의 일부일 수도 있고 → 표현식이 아닌 문
> 2. 그 자체로 문이 될 수도 있다 → 표현식인 문
> ***
> 1과 2 구분법은 **변수에 할당**해보는 방법이다
> * 표현식인 문은 값으로 평가되니 변수에 할당 가능
>   * var x;(변수 선언문은 표현식이 아님! 값처럼 사용 불가)  <br/>x = 100; // 할당문(x = 100) 자체가 표현식 = 값처럼 사용 가능
>   * var foo = x = 100; 가능(표현식인 문은 값처럼 사용 가능). 여기서 console.log(foo); 찍으면 100 나옴
> * 표현식이 아닌 문은 값으로 평가될 수 없으니 변수에 할당하면 에러 발생
>   * var foo = var x; // SyntaxError: Unexpected token var
***
> 완료 값(completion value) :: 크롬 개발자 도구
> 크롬 개발자 도구 > 실행'
> 1. 표현식이 아닌 문 실행 → 언제나 undefined 실행
>   var foo = 10; 를 선언하면 undefined 반환
>   if (true) {}; undefined
> 2. 표현식인 문 →  언제나 평가된 값 반환
>   var num = 10; // undefined
>   100 + num; // 110
>   num = 100; // 100