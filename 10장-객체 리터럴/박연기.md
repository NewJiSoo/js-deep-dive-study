# 10.1 객체란?

자바스크립트는 **객체 기반의 프로그래밍 언어**이며, 자바스크립트를 구성하는 거의 **“모든 것이” 객체다.** **원시 값을 제외**한 나머지 값( **함수**, **배열**, **정규표현식** 등) **모두 객체**다.

원시 타입의 값은 변경 불가능한 값(immutable value) 이지만 객체 타입의 은 변경 가능한 값(mutatble value)이다.

객체는 0개 이상의 **프로퍼티로 구성된 집합**이며, 프로퍼티는 키와 값을 구성된다.

<img src="https://github.com/user-attachments/assets/0a2925f8-fc66-4316-a61a-d1f1c758d311" width=350/>

자바스크립트에서 **사용할 수 잇는 모든 값으 프로퍼티 값이 될 수 있다**. **함수는 일급 객체** 이므로 **값으로 취급**할 수 있다. 따라서 **함수도 프로퍼티 값으로 사용할 수 있다.** 프로퍼티 값이 함수인 경우, **메서드**라 부른다.

<img src="https://github.com/user-attachments/assets/5be07d69-7da4-44a1-ae7a-8c933cf9fb8d" width=350/>

- 객체와 함수
    - 객체는 함수와 밀접한 관계를 가진다. **함수로 객체를 생성하기도 하며 함수 자체가 객체이기도 하다**. 함수와 객체는 분리해서 생각할 수 없는 개념이다.

---

# 10.2 객체 리터럴에 의한 객체 생성

C++나 자바는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다.

- 인스턴스(instance)
    - **인스턴스란 클래스에 의해 생성되어 메모리에 저장된 실체다.** 객체는 클래스와 인스턴스를 포함하는 개념이다. **클래스는 인스턴스를 생성하기 위한 템플릿 역할**을 한다. **인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에** 초첨을 맞춘 용어다.
    - 인스턴스랑 객체랑 비슷한 뜻으로 사용해도 괜춘

자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반 객체지향 언어와 달리 다양한 객체 생성 방법을 지원한다.

1. 객체 리터럴 ( { } )
2. Object  생성자 함수
3. 생성자 함수
4. Object.create 메서드
5. 클래스 (ES6)

**객체 리터럴은 가장 일반적인 방법**이다. 리터럴은 사람이 이해할 수 있는 문자를 사용하여 값을 생성하는 표기법을 말한다. 객체 리터럴은 중괄호( {…} ) 내에 0개 이상의 프로퍼티를 정의한다. **변수에 할당 되는 시점**에 자바스크립트 엔진은 **객체 리터럴을 해석해 객체를 생성**한다.

```tsx
var person = {
	name : "LEE", // 프로퍼티
	sayHello: function(){ // 메서드
		...
	}
}

console.log(typeof person ); // object
console.log(person); //{name : LEE, sayHello : f}
```

**객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다** ( 콤마로 프로퍼티를 구분하는 이유) . 코드 블록의 닫는 중괄호 뒤에는 세미 클론을 붙이지 않는다. 하지만 **객체 리터럴은 값으로 평가되는 표현식**이다. 따라서 **객체 리터럴**의 닫는 **중괄호 뒤에는 세미클론을 붙인다.**

---

# 10.3 프로퍼티

객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.

```tsx
var person = {
	name : "Lee", // 키는 name, 값은 Lee
	age : 20 // 키는 age, 값은 20
}
```

**프로퍼티**를 나열할 때는 **쉼표(,)로 구분**한다. 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않아도 된다.

- 프로퍼티 키 : **빈 문자열을 포함한 모든 문자열**, 심볼 값
- 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모**든 값**

**프로퍼티 키는 식별자 역할**을 한다. 하지만 반드시 **식별자 네이밍 규칙**을 따라야 하는 것은 아니다.

심벌 값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용한다. **프로퍼티 키는 따옴표로 묶어야 한다.** 하지만 **식별자 네이밍 규칙을 준수하는 이름을 사용한 경우 따옴표를 생략할** 수 있다. 반대로 말하면 **식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용**해야 한다.

```tsx
var person = {
	firstName : "Ung-mo" // 식별자 네이밍 규칙을 준수하는 키
	'last-name' : "Lee" // 식별자 네이밍 규칙을 준하지 않는 키
}
```

문자열 또는 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적을 생성할 수 있다. 이런 경우 대괄호 ( [..] )로 묶어야 한다.

```tsx
var obj = {}
var key = "hello"
**obj[key] = "world";**

console.log(obj)// {hello : "world"}
```

빈 문자열을 키로 사용해도 되지만, 키로서의 의미를 갖지 못하므로 권장하지 않는다.

프로퍼티 키에 **문자열, 심볼 값 외의 값**을 사용하면 **암묵적 타입 변환을 통해 문자열**이 된다.

```tsx
var foo ={
		 0 : 1,
		 1 : 2,
		 2 : 3,
	}
```

이미 존재하는 프로퍼티 키를 중복선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어 쓴다. 이때 에러가 발생하지 않으니 주의하자.

```tsx
var foo ={
	name : "LEE",
	name : "ParK",
}

console.log(foo) // {name : "park"}

```

---

# 10.4 메서드

**함수**는 일급 객체로 **값으로 취급**할 수 있기 때문에 **프로퍼티 값으로 사용할 수 있다.**

프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 **메서드라 부른다**. 즉 **메서드는 객체에 묶여 있는 함수**를 의미한다.

---

# 10.5 프로퍼티 접근

프로퍼티에 접근하는 방법 2가지

- 마침표 프로퍼티 접근 연산자(.)를 사용하는 **마침표 표기법**
- 대괄호 프로퍼티 접근 연산자([])를 사용하는 **대괄호 표기법**

프로퍼티 키가 식별자 네이밍 규칙을 준수하는 이름인 경우 마침표 표기법과 대괄호 표기법을 모두 사용할 수 있다.

```tsx
var person = {
	name : "Lee"
}

console.log(person.name) // Lee

console.log(person["name"]) // Lee
```

대괄호 표기법을 사용하는 경우 **대괄호 프로퍼티 접근 연산자** 내부에 지정하는 프로퍼티 키는 반드시 **땀옴표를 값싼 문자열**이다.

```tsx
var person = {
	name :"LEE"
}

console.log(person[name]); // ReferenceError : name is not defined
```

객체에 **존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다**. 이때 에러를 발생하지 않는데 주의하자.

```tsx
var person = {
	name : "Lee"
}

console.log(person.age) //undefined
```

식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키는 반드시 대괄호 표기법을 사용해야 한다. 단, 프로퍼티 키가 숫자로 이뤄진 문자열인 경우 땀옴표를 생략할 수 있다. 그외에 경우 따옴표를 감싸는 문자열이어야 한다.

```tsx
var person = {
	'last-name' : 'lee',
	1 : 10
};

person.'last-name' // SyntaxError
person.last-name // 브라우저 환경 : NaN
								 // Node.js 환경 -> ReferenceError: name is not defined
person[last-name] // ReferenceError : last is not defined
person["last-name"] // lee

// 프로퍼티 키가 숫자로 이뤄진 문자열인 경우 따옴표를 생략할 수 있다.
person.1 // SysntaxError
person."1" // SysntaxError
person[1] // 10 
person['1'] // 10
```

person.last-name의 실행 결과는 Node js와 브라운저 환경에서 결과가 다른 이유가 무엇일까?

`person.last-name`은 자바스크립트 엔진은 먼저 **person.last를 평가**한다. 현재는 last 프로퍼티 키가 없기 때문에 **undefined로 평가**된다. 따라서 `undefined - name`과 같다. 다음으로 자바스크립트 엔진은 **name이라는 식별자를 찾는다. Node.js** 환경에서는 어디에도 n**ame이라는 식별자 선언이 없으므로 ReferenceError : name is not defiend**라는 에러가 발생한다. 그런데 **브라우저 환경**에서는 n**ame이라는 전역 변수가 암묵적으로 존재**한다. 따라서 숫자가 아닌 값들을 빼기 때문에 **NaN**이 된다.

---

# 10.8 프로퍼티 삭제

**delete 연산자**는 객체의 프로퍼티를 삭제한다. delete 연산자의 **피연산자는 프로퍼티 값에 접근할 수 있는 표현식**이어야 한다. 존재하지 않는 프로퍼티인 경우 **에러 없이 무시된다.**

```tsx
var person = {
	name : "Lee"
}

// 프로퍼티 동적 생성
person.age = 20;

// age 프로퍼티 삭제
delete person.age

// address 프로퍼티가 없지만 에러가 발생하지 않고 해당 표현식을 무시한다.
delete person.address

console.log(person) // {name : "Lee"}
```

---

# 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

### 10.9.1 프로퍼티 축약 표현

프로퍼티 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.

```tsx
var x = 1, y = 2;

var obj ={
	x: x,
	y: y
}
```

프로퍼티 값으로 변수를 사용하는 경우 변**수 이름과 프로퍼티 키가 동일한 이름**일 때 **프로퍼티 키를 생략**할 수 있다. 이 때 프로퍼티 키는 변수 이름으로 자동으로 생성된다.

```tsx
var x = 1, y = 2;

var obj = {x,y}
```

### 10.9.2 계산된 프로퍼티 이름

문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수도 있다.

ES5에서는 괄표 표기법을 사용해야 한다.

```tsx
var prefix = "prop"
var i = 0;

var obj = {};

obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;

console.log(obj); // {prop-1: 1,prop-2: 2,prop-3: 3}
```

**ES6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 생성할 수 있다.**

```tsx
const prefix = 'prop';
let i = 0;

const obj = {
	[`${prefix}-${++i}`] : i,
	[`${prefix}-${++i}`] : i,
	[`${prefix}-${++i}`] : i,
}

console.log(obj); // {prop-1: 1,prop-2: 2,prop-3: 3}
```

### 10.9.3 메서드 축약 표현

ES6부터는 메서드를 정의할 때 **function 키워드를 생략한 축약 표현을 사용**할 수 있다.

```tsx
const obj = {
	name : "park",
	sayHi(){
		console.log("Hi!")
	}
}
```

**ES6의 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작**한다. 이는 26.2절에서 살펴본다.
